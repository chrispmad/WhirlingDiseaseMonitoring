---
title: "Prioritization of Water Bodies for Whirling Disease Sampling"
author: "Chris Madsen & John Phelan"
date: "`r Sys.Date()`"
output: 
  html_document:
    css: my_style.css
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
library(tidyverse)
library(readxl)
library(BAMMtools)
library(terra)
#devtools::install_github("yutannihilation/ggsflabel")
library(ggsflabel)
library(tidyterra)
library(sf)
library(bcdata)

requery_occs = F
k_breaks = 5 # number of breaks for k-means clustering

base_dir = stringr::str_extract(getwd(),"C:\\/Users\\/[a-zA-Z]+")
onedrive_wd = paste0(str_extract(getwd(),"C:/Users/[A-Z]+/"),"OneDrive - Government of BC/data/")
lan_root = "//SFP.IDIR.BCGOV/S140/S40203/WFC AEB/General/"

#k-means clustering functions
source("utils/bin_to_kmeans_func.R")
source("utils/getKMeansBreaks_func.R")

## GGplot label convenience function
source("utils/bin_info_labs_ggplot_preset.R")
```

```{r load_data}
if(!file.exists('data/anger_survey.rds')){
  insp_from_wd_inf_to_wb = sf::read_sf("W:/CMadsen/Projects/ZQMussels/data/Waterbodies_with_Inspection_Data_Summaries_all_years_WD_Infected_Areas.gpkg")
  saveRDS(insp_from_wd_inf_to_wb, file = 'data/inspections_WD_outside_BC.rds')
} else {
  if(!exists("insp_from_wd_inf_to_wb")){
  insp_from_wd_inf_to_wb = readRDS('data/inspections_WD_outside_BC.rds')
  }
}

if(!exists("insp_from_wd_bc_wb")){
insp_from_wd_bc_wb = sf::read_sf("W:/CMadsen/Projects/ZQMussels/data/Waterbodies_with_Inspection_Data_Summaries_all_years_BC_WD_Infected_Waterbodies.gpkg")
}

if(!file.exists('data/anger_survey.rds')){
  ang = sf::read_sf("W:/CMadsen/shared_data_sets/freshwater_fisheries_society_angler_survey_2022_2023.gpkg")
  saveRDS(ang, file = 'data/anger_survey.rds')
} else {
  ang = readRDS('data/anger_survey.rds')
}

# Which waterbodies were sampled last year?
wbs_sampled_2024 = readxl::read_excel(paste0(lan_root,"2 SCIENCE - Invasives/SPECIES/Whirling Disease/Monitoring/WD_sampling_results_fish_eDNA_used_for_making_maps_CMADSEN.xlsx")) |> 
  purrr::set_names(snakecase::to_snake_case) |> 
  dplyr::filter(sampled_in_2024_y_n == 'Y')
```

## Prioritization Equation {.tabset}

Priority Equation:

$$
P_w = EnteringBC_w + InsideBC_w + FishingDays_w + WaterAuths_w
$$

Where *P~w~* is the priority ranking of a given waterbody, EnteringBC~w~ is the binned number of watercraft destined for a given waterbody from a Whirling Disease-infected state/province/territory that is not BC, InsideBC~w~ is the binned number of watercraft destined for a given waterbody coming from a Whirling Disease-infected waterbody in BC, Fishingdays~w~ is the binned fishing days reported for a given waterbody, and WaterAuths~w~ is the binned number of current water authorization points within a given waterbody.

### Watercraft Inspections Coming from Infected States/Provinces

These are binned watercraft inspections originating from infected states or provinces, as well as from waterbodies in British Columbia (BC) that are infected with whirling disease. The bins represent the number of watercraft headed to BC waterbodies from infected states, provinces, or infected BC waterbodies.

```{r watercraft_insp_from_inf_areas}

# Note: the above file can kind of only be modified / updated on Chris' computer, as it depends on the ZQMussels R project (specifically, it's Options.csv file) and the {imdp} R package... but the output gets saved to Chris' W drive, so that should be accessible for everyone!

insp_from_wd_inf_to_wb_b = bin_to_kmeans(insp_from_wd_inf_to_wb, 'TotalInspections', k_breaks)

# Strip out pacific ocean and 'dry storage' destinations for watercraft.
insp_from_wd_inf_to_wb_b = insp_from_wd_inf_to_wb_b |> 
  dplyr::filter(!GNIS_NA %in% c("Pacific Ocean","Dry Storage"))

bins_title = getKMeansBreaks(insp_from_wd_inf_to_wb_b$TotalInspections, k = k_breaks)

# Plot showing binned numbers of watercraft headed to waterbodies in BC from infected states / provinces as well as infected waterbodies in BC.
if(!interactive()){
ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = insp_from_wd_inf_to_wb_b, aes(
    fill = TotalInspections_kmeans_bin,
    col = TotalInspections_kmeans_bin)) + 
  ggthemes::theme_map() + 
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) + 
  bin_info_labs(bins_title)
}
wb_list = insp_from_wd_inf_to_wb_b |> 
  dplyr::select(GNIS_NA, WATERSH, TotalInspections, TotalInspections_kmeans_bin )
```

Currently, the number of distinct waterbodies with information is `r nrow(wb_list)`.

### Watercraft Inspections Coming from Infected Waterbodies in BC

These are where boats are going when coming from infected BC waterbodies.

```{r watercraft_insp_from_inf_wbs_in_bc}
insp_from_wd_bc_wb_b = bin_to_kmeans(insp_from_wd_bc_wb, 'TotalInspections', k_breaks)

# Strip out pacific ocean and 'dry storage' destinations for watercraft.
insp_from_wd_bc_wb_b = insp_from_wd_bc_wb_b |> 
  dplyr::filter(!GNIS_NA %in% c("Pacific Ocean","Dry Storage"))

bins_title_bc = getKMeansBreaks(insp_from_wd_bc_wb_b$TotalInspections, k = k_breaks)

# Plot showing binned numbers of watercraft headed to waterbodies in BC from infected states / provinces as well as infected waterbodies in BC.
if(!interactive()){
ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = insp_from_wd_bc_wb_b, aes(fill = TotalInspections_kmeans_bin ,
                                             col = TotalInspections_kmeans_bin )) + 
  ggthemes::theme_map() + 
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) + 
  bin_info_labs(bins_title_bc)
}
# Identify any water bodies that aren't already in the list.
new_wb_for_list = insp_from_wd_bc_wb_b |> 
  dplyr::anti_join(
    wb_list |> 
      sf::st_drop_geometry() |> 
      dplyr::select(GNIS_NA, WATERSH)
  ) |> 
  dplyr::select(GNIS_NA, WATERSH,
                insp_from_wd_bc_wb = TotalInspections,
                insp_from_wd_bc_wb_kmeans_bin = TotalInspections_kmeans_bin )

wb_already_in_list = insp_from_wd_bc_wb_b |> 
  dplyr::filter(paste0(WATERSH,GNIS_NA) %in% paste0(wb_list$WATERSH,wb_list$GNIS_NA)) |> 
  dplyr::select(GNIS_NA, WATERSH, insp_from_wd_bc_wb = TotalInspections,
                insp_from_wd_bc_wb_kmeans_bin = TotalInspections_kmeans_bin ) |> 
  sf::st_drop_geometry()

# Not new waterbodies per list, per se, but new columns.
wb_list = wb_list |> 
  dplyr::left_join(
    wb_already_in_list
  )

# Are there any new waterbodies to be added to the wb_list?
if(nrow(new_wb_for_list) > 0){
  wb_list = wb_list |> 
    dplyr::bind_rows(
      new_wb_for_list
    )
}
```

Currently, the number of distinct waterbodies with information is `r nrow(wb_list)`.

```{r}
# ### Freshwater Fisheries Society Angler Survey (2022-2023)
# 
# ```{r}
# # We do have angler use as a raster on onedrive, but we also have the original polygon object on the W: drive.
# # ang = terra::rast(paste0(onedrive_wd,"CNF/DFO_angling_survey_days_fished_raster.tif"))
# 
# 
# # Drop waterbodies with no fishing
# ang = ang |> 
#   dplyr::filter(!is.na(days_fished))
# 
# # # Rename some columns.
# # ang = ang |> 
# #   dplyr::rename(WATERSH = WATERSHED_GROUP_ID,
# #                 GNIS_NA = Waterbody)
# 
# # Summarise at the waterbody name and watershed number level.
# ang_s = ang |> 
#   dplyr::group_by(GNIS_NA, WATERSH) |> 
#   dplyr::summarise(days_fished = sum(days_fished,na.rm=T)) |> 
#   dplyr::ungroup()
# 
# ang_s = bin_to_kmeans(ang_s, "days_fished", k_breaks)
# 
# bins_title_ang = getKMeansBreaks(ang_s$days_fished, k_breaks)
# 
# ggplot() + 
#   geom_sf(data = bcmaps::bc_bound()) +
#   geom_sf(data = ang_s, aes(col = days_fished_kmeans_bin, fill = days_fished_kmeans_bin)) + 
#   scale_fill_brewer(palette = 'Spectral', direction = -1) +
#   scale_color_brewer(palette = 'Spectral', direction = -1) + 
#   ggthemes::theme_map() + 
#   bin_info_labs(bins_title_ang)
# 
# # Identify any water bodies that aren't already in the list.
# new_wb_for_list = ang_s |> 
#   dplyr::anti_join(
#     wb_list |> 
#       sf::st_drop_geometry() |> 
#       dplyr::select(GNIS_NA, WATERSH)
#   ) |> 
#   dplyr::select(WATERSH, GNIS_NA, days_fished, days_fished_kmeans_bin)
# 
# wb_already_in_list = ang_s |> 
#   dplyr::filter(paste0(WATERSH,GNIS_NA) %in% paste0(wb_list$WATERSH,wb_list$GNIS_NA)) |> 
#   dplyr::select(GNIS_NA, WATERSH, days_fished, days_fished_kmeans_bin) |> 
#   sf::st_drop_geometry()
# 
# # Not new waterbodies per list, per se, but new columns.
# wb_list = wb_list |> 
#   dplyr::left_join(
#     wb_already_in_list
#   )
# 
# # Are there any new waterbodies to be added to the wb_list?
# if(nrow(new_wb_for_list) > 0){
#   wb_list = wb_list |> 
#     dplyr::bind_rows(
#       new_wb_for_list
#     )
# }
```

### 2023-2024 iSEA Fishing Days

```{r}
dfo_ang = readRDS(paste0(onedrive_wd,"fishing_days_by_waterbody_and_watershed.rds"))
# 
# # wbs present in both
# nrow(ang_s |> dplyr::filter(GNIS_NA %in% dfo_ang$waterbody))
# # wbs only in the 'old' angler survey data.
# nrow(ang_s |> dplyr::filter(!GNIS_NA %in% dfo_ang$waterbody))

# If > 95% of the lakes in the old dataset are present in the new, no question to just move to the new dataset. Numbers are wildly different in scale, though the ordering might be kind of similar.

binned_ang<-bin_to_kmeans(dfo_ang, "fishing_days" , k_breaks)
bin_vals<-getKMeansBreaks(binned_ang$fishing_days, k = k_breaks)                          
if(!interactive()){
 ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = binned_ang, aes(col = fishing_days_kmeans_bin, fill = fishing_days_kmeans_bin)) +
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) +
  ggthemes::theme_map() +
  bin_info_labs(bin_vals,'Fishing Days')
}

 binned_ang<-st_transform(binned_ang, st_crs(wb_list))
binned_ang<- binned_ang |> 
  dplyr::rename( GNIS_NA = waterbody,
                WATERSH = watershed,
                days_fished = fishing_days,
                days_fished_kmeans_bin = fishing_days_kmeans_bin)
# Identify any water bodies that aren't already in the list.
new_wb_for_list = binned_ang |>
  dplyr::anti_join(
    wb_list |>
      sf::st_drop_geometry() |>
      dplyr::select(GNIS_NA, WATERSH)
  ) |>
  dplyr::select(WATERSH, GNIS_NA, days_fished, days_fished_kmeans_bin)

wb_already_in_list = binned_ang |>
  dplyr::filter(paste0(WATERSH,GNIS_NA) %in% paste0(wb_list$WATERSH,wb_list$GNIS_NA)) |>
  dplyr::select(GNIS_NA, WATERSH, days_fished, days_fished_kmeans_bin) |>
  sf::st_drop_geometry()

# Not new waterbodies per list, per se, but new columns.
wb_list = wb_list |>
  dplyr::left_join(
    wb_already_in_list
  )

# Are there any new waterbodies to be added to the wb_list?
if(nrow(new_wb_for_list) > 0){
  wb_list = wb_list |>
    dplyr::bind_rows(
      new_wb_for_list
    )
}


```

Currently, the number of distinct waterbodies with information is `r nrow(wb_list)`.



```{r kfo_filter}


# save it to onedrive
if(!file.exists(paste0(onedrive_wd,"kfo.rds"))){
  kfo <- bcdc_query_geodata("known-bc-fish-observations-and-bc-fish-distributions") |>
  collect() |> 
  st_as_sf()
  saveRDS(kfo, paste0(onedrive_wd,"kfo.rds"))
} else {
  kfo = readRDS(paste0(onedrive_wd,"kfo.rds"))
}

# kfo_spp<- kfo |> 
#   dplyr::select(SPECIES_NAME, geometry)
# 
# joined <- st_join(kfo_spp, wb_list, join = st_intersects, left = FALSE)
# 
# fish_summary <- joined |>
#   group_by(GNIS_NA, WATERSH) |> 
#   summarize(
#     known_fish = paste(sort(unique(SPECIES_NAME)), collapse = ", "),
#     .groups = "drop"
#   )
# 
# wb_list <- wb_list |>
#   left_join(fish_summary, by = c("GNIS_NA", "WATERSH"))

# Filter KFO to fish within waterbody bounds (fast!)
kfo_spp <- kfo |> 
  st_filter(wb_list, .predicate = st_intersects) |> 
  select(SPECIES_NAME, geometry)

# Join from fish to waterbodies (faster)
joined <- st_join(kfo_spp, wb_list, join = st_intersects, left = FALSE)

# Summarize known fish by waterbody
fish_summary <- joined |>
  group_by(GNIS_NA, WATERSH) |> 
  summarize(
    known_fish = paste(sort(unique(SPECIES_NAME)), collapse = ", "),
    .groups = "drop"
  )


new_wb_fish <- fish_summary |>
  anti_join(
    wb_list |> st_drop_geometry() |> select(GNIS_NA, WATERSH),
    by = c("GNIS_NA", "WATERSH")
  )

wb_fish_existing <- fish_summary |>
  filter(paste0(WATERSH, GNIS_NA) %in% paste0(wb_list$WATERSH, wb_list$GNIS_NA))

wb_list<- wb_list |>
  left_join(wb_fish_existing |> st_drop_geometry(), by = c("GNIS_NA", "WATERSH"))
```



```{r commented_hatcheries}

# ### Hatchery Locations
# 
# Locations of salmond hatcheries across the province.
# 
# ```{r hatchery raster}
# hatchery_rast<-terra::rast(paste0(onedrive_wd,"raster/aquaculture_presence_absence_raster.tif"))
# #plot
# 
# hatchery_points <- terra::as.points(hatchery_rast, na.rm = TRUE)
# 
# hatchery_sf <- sf::st_as_sf(hatchery_points)
# 
# # Filter to only presence points (value = 1)
# hatchery_presence_sf <- hatchery_sf[hatchery_sf$sum == 1, ] |> 
#   dplyr::rename(hatchery_present = sum)
# 
# # Plot with a single color and simplified legend
# ggplot() +
#   geom_sf(data = bcmaps::bc_bound()) +
#   geom_sf(data = hatchery_presence_sf, color = "darkred", size = 1) +
#   ggthemes::theme_map() +
#   labs(color = NULL, subtitle = "Hatchery Presence in BC") +
#   theme(legend.position = "none")
# 
# # Add in overlap of hatcheries to wb_list
# hatcheries_by_wb = hatchery_presence_sf |> 
#       sf::st_transform(3005) |> 
#   sf::st_join(wb_list |> dplyr::select(GNIS_NA,WATERSH)) |> 
#   sf::st_drop_geometry() |> 
#   dplyr::filter(!is.na(GNIS_NA)) |> 
#   dplyr::group_by(GNIS_NA, WATERSH) |> 
#   dplyr::reframe(hatchery_present = sum(hatchery_present))
# 
# wb_list = wb_list |> 
#   dplyr::left_join(
#     hatcheries_by_wb
#   )
# ```
```

### Watershed Groups with Fish Samples with WD

```{r}
ws = sf::read_sf("W:/CMadsen/shared_data_sets/subwatersheds_BC.shp")

edna_results = readxl::read_excel(paste0(lan_root,"2 SCIENCE - Invasives/SPECIES/Whirling Disease/Monitoring/WD_sampling_results_fish_eDNA_used_for_making_maps_CMADSEN.xlsx")) |> 
  purrr::set_names(snakecase::to_snake_case)

pos_fish_plus_parasite_edna = edna_results |> 
  dplyr::filter(stringr::str_detect(fish_sampling_results_q_pcr_mc_detected, 'Positive') | e_dna_results_mc == 'Weak Detection')

pos_fish_edna_sf = sf::st_as_sf(pos_fish_plus_parasite_edna,coords = c('long','lat'), crs = 4326)

# Also pull in emerald lake, find its centroid.
emerald_lake = bcdata::bcdc_query_geodata('freshwater-atlas-lakes') |> 
  bcdata::filter(GNIS_NAME_1 == 'Emerald Lake', WATERBODY_POLY_ID == 705013945) |> 
  collect()

emerald_lake_centroid = emerald_lake |> 
  sf::st_centroid()

ws_w_edna_fish = ws |> 
  sf::st_filter(
    pos_fish_edna_sf |> 
      sf::st_transform(3005) |> 
      dplyr::bind_rows(emerald_lake_centroid)
  )

ws_bbox = sf::st_bbox(ws_w_edna_fish |> sf::st_buffer(dist = 50000))

if(!interactive()){
ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) + 
  geom_sf(data = ws_w_edna_fish, aes(fill = "Positive Fish \neDNA Results")) +
  geom_sf(data = pos_fish_edna_sf, col = 'lightgreen') + 
  geom_sf(data = emerald_lake, fill = 'lightgreen', col = 'lightgreen') + 
  geom_sf_label(data = emerald_lake, aes(label = 'Emerald Lake'), nudge_x = 80000) +
  # geom_sf_label(data = pos_fish_edna_sf, aes(label = sample_site_name), nudge_x = 80000, nudge_y = -100000) +
  ggsflabel::geom_sf_label_repel(data = pos_fish_edna_sf,
                                 aes(label = sample_site_name),
                        force = 10, seed = 10) +
  labs(fill = 'eDNA') + 
  coord_sf(xlim = ws_bbox[c(1,3)],
           ylim = ws_bbox[c(2,4)]) + 
  ggthemes::theme_map() + 
  ggspatial::annotation_scale()
}

wb_list = wb_list |> 
  dplyr::mutate(fish_edna_positive_in_watershed = WATERSH %in% ws_w_edna_fish$WATERSHED_)
```

### Connectivity of Infected Watersheds {.tabset}

```{r}
if(!file.exists("data/named_watersheds_of_bc.rds")){
  # small_watersheds = bcdc_query_geodata('freshwater-atlas-named-watersheds') |> 
  small_watersheds = bcdc_query_geodata('wsa-third-order-and-greater-watersheds-50-000') |> 
    collect()
  saveRDS(small_watersheds, "data/named_watersheds_of_bc.rds")
} else {
  small_watersheds = readRDS("data/named_watersheds_of_bc.rds")
  # test = small_watersheds |> 
  #   # filter for 2nd order watersheds
  #   dplyr::filter(str_detect(FWA_WATERSHED_CODE,"^[0-9]{3}-[^0]{6}"))
}

pos_fish_edna_sf_albers = pos_fish_edna_sf |> 
  sf::st_transform(3005)

small_watersheds_infected = small_watersheds |> 
  sf::st_filter(pos_fish_edna_sf_albers)

watershed_codes_infected = unique(str_extract(small_watersheds_infected$WSD_ID,'^.{4}'))

# watershed groups?
wsg = bcdc_query_geodata('freshwater-atlas-watershed-groups') |> 
  filter(WATERSHED_GROUP_CODE %in% watershed_codes_infected) |> 
  collect()

infected_rivers = bcdc_query_geodata('freshwater-atlas-rivers') |> 
  filter(INTERSECTS(small_watersheds_infected)) |> 
  collect() |> 
  dplyr::group_by(BLUE_LINE_KEY,GNIS_NAME_1,FWA_WATERSHED_CODE) |> 
  dplyr::summarise()
```

The following tabs describe our analysis of infected watersheds and which neighbouring watersheds are downstream and hydrologically connected.

#### Infected Watersheds and Rivers Therein

```{r show_infected_watersheds}
if(!interactive()){
ggplot() + 
  geom_sf(data = wsg, col = 'black', fill = 'white', lwd = 1) +
  geom_sf(data = small_watersheds_infected, fill = 'red') + 
  geom_sf(data = infected_rivers, col = 'darkblue', fill = 'darkblue') +
  geom_sf(data = pos_fish_edna_sf_albers)
}
```

```{r}
adj_small_watersheds = small_watersheds |> 
  sf::st_filter(
    small_watersheds_infected |> 
      sf::st_buffer(dist = 50)
  )
```

#### Add Adjacent Watersheds

```{r show adjacent_small_watersheds}
#### Infected Watersheds
if(!interactive()){
ggplot() + 
  geom_sf(data = wsg, col = 'black', fill = 'white', lwd = 1) +
  geom_sf(data = adj_small_watersheds, fill = 'yellow') +
  geom_sf(data = small_watersheds_infected, fill = 'red') +
  geom_sf(data = infected_rivers, col = 'darkblue', fill = 'darkblue') +
  geom_sf(data = pos_fish_edna_sf_albers)
}
```

```{r find_rivers_downstream_of_infected_watershed_rivers}
# # Use the FWA_WATERSHED_CODE to find rivers downstream of infected rivers
# infected_rivers_fwa = unique(infected_rivers$FWA_WATERSHED_CODE)
# infected_rivers_ds_fwa = str_replace(infected_rivers_fwa, "[0-9]{6}(?=-000000)","000000")
# 
# infected_rivers_downstream = bcdc_query_geodata('freshwater-atlas-rivers') |> 
#   filter(FWA_WATERSHED_CODE %in% infected_rivers_ds_fwa) |> 
#   collect() |> 
#   dplyr::group_by(BLUE_LINE_KEY,GNIS_NAME_1,FWA_WATERSHED_CODE) |> 
#   dplyr::summarise()
```

```{r show_rivers_downstream_of_rivers_in_infected_watersheds}
#### Rivers Downstream of Rivers in Infected Watersheds 
# ggplot() + 
#   geom_sf(data = wsg, col = 'black', fill = 'white', lwd = 1) +
#   geom_sf(data = adj_small_watersheds, fill = 'yellow') +
#   geom_sf(data = small_watersheds_infected, fill = 'red') +
#   geom_sf(data = infected_rivers, col = 'darkblue', fill = 'darkblue') + 
#   geom_sf(data = infected_rivers_downstream)
```

```{r establish_elevation_differences}

# #### Access elevation data
# 
# elev = elevatr::get_elev_raster(locations = sf::st_bbox(wsg), z = 8)
# 
# # Find mean elevation for each small watershed.
# elev_per_ID = terra::extract(terra::rast(elev),terra::vect(adj_small_watersheds)) |> 
#   tidyr::tibble()
# 
# names(elev_per_ID)[2] = "elev_in_meters"
# 
# elev_per_ID = elev_per_ID |> 
#   dplyr::group_by(ID) |> 
#   dplyr::reframe(mean_elev = mean(elev_in_meters))
# 
# adj_small_watersheds$mean_elev = elev_per_ID$mean_elev
# 
# if(!interactive()){
# ggplot() + 
#   tidyterra::geom_spatraster(data = terra::rast(elev), alpha = 0.5) +
#   geom_sf(data = wsg, fill = 'transparent', col = 'white') + 
#   geom_sf(data = adj_small_watersheds, aes(fill = mean_elev)) + 
#   labs(fill = 'elevation (m)') + 
#   coord_sf(xlim = sf::st_bbox(wsg)[c(1,3)],
#            ylim = sf::st_bbox(wsg)[c(2,4)])
# }
```

```{r determine_which_of_adjacent_watersheds_are_lower_downstream}
# # Join the mean elevations to adj_small_watersheds
# 
# # 1st) For each infected watershed, find the adjacent watersheds (e.g. 5)
# # 2nd) st_filter using river that is present in infected watershed (probs 1-2)
# # 3rd) filter adjacent watersheds such that they are lower in mean elevation
# #      than the infected watershed.
# infectable_adj_watersheds = small_watersheds_infected |> 
#   dplyr::group_by(GAZETTED_NAME) |> 
#   dplyr::group_split() |> 
#   purrr::map( ~ {
# 
#     # Find the adjacent small watersheds of the current .x
#     small_ws_adj_to_x = adj_small_watersheds |> 
#       sf::st_filter(
#         .x |> 
#           sf::st_buffer(dist = 50)
#       )
#       
#     # Make sure there's a river that connects them.
#     rivers_in_x = infected_rivers |> 
#       dplyr::ungroup() |> 
#       sf::st_filter(.x)
#     
#     small_ws_adj_to_x = small_ws_adj_to_x |> 
#       sf::st_filter(rivers_in_x)
#     
#     small_ws_adj_to_x
#     # # filter adjacent watersheds such that they are lower in mean elevation 
#     # # than the infected watershed.
#     # cutoff_elev = adj_small_watersheds |> 
#     #   dplyr::filter(GAZETTED_NAME == .x$GAZETTED_NAME) |> 
#     #   dplyr::pull(mean_elev)
#     # 
#     # infectable_small_watersheds = small_ws_adj_to_x |> 
#     #   dplyr::filter(mean_elev <= cutoff_elev)
#     # 
#     # infectable_small_watersheds
#   }) |> 
#   dplyr::bind_rows() |> 
#   dplyr::filter(!duplicated(GAZETTED_NAME))
```



```{r}

# #### Infectable Downstream Watersheds
# 
# if(!interactive()){
# ggplot() + 
#   geom_sf(data = wsg, col = 'black', fill = 'white', lwd = 1) +
#   geom_sf(data = adj_small_watersheds, fill = 'yellow') +
#   geom_sf(data = infectable_adj_watersheds, fill = 'orange') +
#   geom_sf(data = small_watersheds_infected, fill = 'red') +
#   geom_sf(data = infected_rivers, col = 'darkblue', fill = 'darkblue') +
#   geom_sf(data = pos_fish_edna_sf_albers)
# }
```

#### Add Lakes and Rivers

```{r}
# Snag all rivers AND LAKES! in the adjacent watershed polygons
rivers_in_infectable_adj_watersheds = bcdc_query_geodata('freshwater-atlas-rivers') |> 
  filter(INTERSECTS(adj_small_watersheds)) |> 
  collect() |> 
  dplyr::group_by(BLUE_LINE_KEY,GNIS_NAME_1,FWA_WATERSHED_CODE) |> 
  dplyr::summarise()

lakes_in_infectable_adj_watersheds = bcdc_query_geodata('freshwater-atlas-lakes') |> 
  filter(INTERSECTS(adj_small_watersheds)) |> 
  collect() |> 
  dplyr::group_by(BLUE_LINE_KEY,GNIS_NAME_1,FWA_WATERSHED_CODE) |> 
  dplyr::summarise()

rivers_in_infectable_adj_watersheds = rivers_in_infectable_adj_watersheds |> 
  dplyr::ungroup() |> 
  sf::st_filter(adj_small_watersheds)

lakes_in_infectable_adj_watersheds = lakes_in_infectable_adj_watersheds |> 
  dplyr::ungroup() |> 
  sf::st_filter(adj_small_watersheds)
```

```{r show_with_lakes_and_rivers}
if(!interactive()){
ggplot() + 
  geom_sf(data = wsg, col = 'black', fill = 'white', lwd = 1) +
  geom_sf(data = adj_small_watersheds, fill = 'yellow') +
  # geom_sf(data = infectable_adj_watersheds, fill = 'orange') + 
  geom_sf(data = small_watersheds_infected, fill = 'red') +
  geom_sf(data = rivers_in_infectable_adj_watersheds, fill = 'blue', col = 'blue')+
  geom_sf(data = lakes_in_infectable_adj_watersheds, fill = 'blue', col = 'blue')+
  geom_sf(data = infected_rivers, col = 'darkblue', fill = 'darkblue') +
  geom_sf(data = pos_fish_edna_sf_albers)
}
```

#### Add Fish Passage Barriers (green) and Dams (brown)

```{r}
# Query PSCIS for fish passage barriers.
pscis_in_area = bcdc_query_geodata('pscis-assessments') |> 
  filter(INTERSECTS(adj_small_watersheds)) |> 
  collect()

# Filter potential fish passage barriers to within 50m of rivers.
pscis_near_rivers = pscis_in_area |> 
  sf::st_filter(
    sf::st_buffer(infected_rivers, dist = 50)
  )

dams = bcdc_query_geodata('bc-dams') |> 
  filter(INTERSECTS(adj_small_watersheds)) |> 
  collect()

# Clip rivers with PSCIS , buffered by like 100 meters?
pscis_near_rivers_buff = sf::st_buffer(pscis_near_rivers, dist = 100)

pscis_in_area = pscis_in_area |> sf::st_filter(adj_small_watersheds)
pscis_near_rivers = pscis_near_rivers |> sf::st_filter(adj_small_watersheds)
dams = dams |> sf::st_filter(adj_small_watersheds)


if(!interactive()){
ggplot() + 
  geom_sf(data = wsg, col = 'black', fill = 'white', lwd = 1) +
  geom_sf(data = adj_small_watersheds, fill = 'yellow') + 
  # geom_sf(data = infectable_adj_watersheds, fill = 'orange') + 
  geom_sf(data = small_watersheds_infected, fill = 'red') + 
  geom_sf(data = rivers_in_infectable_adj_watersheds, fill = 'blue', col = 'blue') +
  geom_sf(data = lakes_in_infectable_adj_watersheds, fill = 'blue', col = 'blue') +
  geom_sf(data = infected_rivers, fill = 'darkblue', col = 'darkblue') + 
  geom_sf(data = pscis_in_area, col = 'green') +
  geom_sf(data = pscis_near_rivers, col = 'green') +
  geom_sf(data = dams |> sf::st_buffer(dist = 1000), col = 'brown', fill = 'brown') +
  geom_sf(data = pos_fish_edna_sf_albers)
}
```

### Downstream Infectable Waterbodies

```{r}
downstream_infectable_waterbodies = rivers_in_infectable_adj_watersheds |> 
  dplyr::bind_rows(
    lakes_in_infectable_adj_watersheds
  ) |> 
  dplyr::ungroup() |> 
  sf::st_join(adj_small_watersheds |> 
                dplyr::select(watershed_name = GAZETTED_NAME,
                              stream_magnitude = STREAM_MAGNITUDE))
  
downstream_infectable_waterbodies_no_geom = downstream_infectable_waterbodies |> 
  sf::st_drop_geometry() |> 
  dplyr::select(-FWA_WATERSHED_CODE) |> 
  dplyr::rename(waterbody_name = GNIS_NAME_1) |> 
  dplyr::arrange(watershed_name)

openxlsx::write.xlsx(downstream_infectable_waterbodies_no_geom, file = "output/list_of_infectable_downstream_waterbodies.xlsx")

DT::datatable(downstream_infectable_waterbodies_no_geom)

wb_list_infectables = wb_list |> 
  sf::st_filter(
    downstream_infectable_waterbodies
  ) |> 
  dplyr::mutate(infectable = TRUE) |> 
  dplyr::select(infectable, GNIS_NA, WATERSH) |> 
  sf::st_drop_geometry()

wb_list = wb_list |> 
  dplyr::left_join(wb_list_infectables) |> 
  dplyr::mutate(infectable = tidyr::replace_na(infectable, FALSE))
```

### Water Authorizations

```{r snag_water_auths}
if(!file.exists('data/water_authorization_points.rds')){
  water_apps = bcdc_query_geodata('water-approval-points') |> 
    # filter(INTERSECTS(wsg)) |> 
    collect()
  water_apps = sf::st_filter(water_apps, bcmaps::bc_bound())
  saveRDS(water_apps,'data/water_authorization_points.rds')
} else {
  water_apps = readRDS('data/water_authorization_points.rds')
}

water_apps = water_apps |> 
  dplyr::mutate(approval_status = dplyr::case_when(
    APPROVAL_STATUS %in% c("Abandoned","Aborted","Cancelled") ~ "Abandoned/Cancelled",
    T ~ APPROVAL_STATUS
  ))

library(leaflet)
uniq_app_stat = unique(water_apps$approval_status)
uniq_app_stat = na.omit(uniq_app_stat)

app_stat_leg = colorFactor(palette = 'Spectral', domain = uniq_app_stat)

l = leaflet() |> 
    addTiles() |> 
  addLayersControl(position = 'bottomleft',
                   overlayGroups = uniq_app_stat,
                   options = layersControlOptions(collapsed = F))

zIndex_base = 300
for(app_stat in uniq_app_stat){
  zIndex_base = zIndex_base + 100
  l = l |> 
    addMapPane(name = app_stat, zIndex = zIndex_base) |> 
    addCircleMarkers(
      data = sf::st_transform(water_apps[water_apps$approval_status == app_stat,], 4326),
      label = app_stat,
      color = 'black',
      weight = 1,
      # color = ~app_stat_leg(approval_status),
      fillColor = ~app_stat_leg(approval_status),
      fillOpacity = 0.8,
      group = app_stat,
      options = pathOptions(pane = app_stat)
    )
}
    
l = l |> 
  addLegend(pal = app_stat_leg, values = uniq_app_stat)

if(!interactive()){
  # ggplot() + 
  #   geom_sf(data = bcmaps::bc_bound()) + 
  #   geom_sf(data = water_apps, aes(col = approval_status))
  l
}

water_apps_w_wb_info = water_apps |> 
  dplyr::filter(approval_status %in% c('Current')) |>
  sf::st_join(wb_list |> dplyr::select(GNIS_NA,WATERSH))

water_apps_w_wb_cumulative = water_apps |> 
  dplyr::filter(approval_status %in% c("Current","Superseded")) |>
  sf::st_join(wb_list |> dplyr::select(GNIS_NA,WATERSH)) |> 
  sf::st_drop_geometry() |> 
  dplyr::filter(!is.na(GNIS_NA)) |> 
  dplyr::count(GNIS_NA,WATERSH, name = "cumulative_authorizations")
  

number_water_apps_per_wb = water_apps_w_wb_info |> 
  dplyr::filter(!is.na(GNIS_NA)) |> 
  sf::st_drop_geometry() |> 
  dplyr::count(GNIS_NA,WATERSH, name = "active_water_authorizations")


# Bin!
number_water_apps_per_wb = bin_to_kmeans(number_water_apps_per_wb, 'active_water_authorizations', k_breaks)

water_auths_bins = getKMeansBreaks(number_water_apps_per_wb$active_water_authorizations, k = k_breaks)

wbs_with_water_apps = wb_list |> 
  dplyr::inner_join(
    number_water_apps_per_wb
  )

if(!interactive()){
 ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = wbs_with_water_apps, aes(col = active_water_authorizations_kmeans_bin, fill = active_water_authorizations_kmeans_bin)) +
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) +
  ggthemes::theme_map() +
  bin_info_labs(water_auths_bins,"Water Auths")
}


wb_list = wb_list |> 
  dplyr::left_join(number_water_apps_per_wb) |> 
  dplyr::mutate(active_water_authorizations = tidyr::replace_na(active_water_authorizations, 0))
```

If we only take Water Authorization points of status type 'Current' and drop all the rest, there are `r nrow(water_apps |> dplyr::filter(approval_status == 'Current'))` points to consider; `r nrow(water_apps_w_wb_info |> dplyr::filter(!is.na(GNIS_NA)))` of these overlap with one of the waterbodies with at least one watercraft inspection tied to it or at least one mention of it in the angler survey data.



```{r overlay_tubifex_results}

### Overlay of Positive Tubifex Results

# vi. Overlay eDNA results for tubifex

tubifex_results = edna_results |>
  dplyr::filter(stringr::str_detect(e_dna_results_tubifex, 'Detected'))

tubifex_results_sf = sf::st_as_sf(tubifex_results, coords = c('long','lat'), crs = 4326)

# if(!interactive()){
# ggplot()+
#   geom_sf(data = bcmaps::bc_bound()) +
#   geom_sf(data = tubifex_results_sf, aes(col = e_dna_results_tubifex)) +
#   labs(col = 'Tubifex \neDNA Results') +
#   scale_color_brewer(palette = "Set1") +
#   ggthemes::theme_map() +
#   ggspatial::annotation_scale()+
#   theme(legend.position = 'bottom')
# }

ws_w_edna_tubifex = ws |>
  sf::st_filter(
    tubifex_results_sf |>
      sf::st_transform(3005) |>
      dplyr::bind_rows(emerald_lake_centroid)
  )

wb_list = wb_list |>
  dplyr::mutate(tubifex_edna_positive_in_watershed = WATERSH %in% ws_w_edna_tubifex$WATERSHED_)

```

```{r tubifex_maxent}
# ### Tubifex MaxEnt Model Results
# 
# vii. If tubifex density is accurate, overlay tubifex density map binned into presence/absence (doesn't contribute to score)
# 
# Maxent produced habitat suitability maps, based on a set of pre-determined parameters. It uses the presences of tubifex to assess the rest of the province and determine where tubifex is likely to be found. This is then assigned value of habitat/not-habitat based on internal fitting of parameters.
# 
tubifex_maxent<- terra::rast("output/habitat_maxent_tubifex_binary_fc.LQ_rm.3.tif")
#create factors for the values in the raster
tubifex_maxent <- terra::as.factor(tubifex_maxent)

if(!interactive()){
# ggplot() +
#   tidyterra::geom_spatraster(data = tubifex_maxent) +  # Raster layer
#   geom_sf(data = bcmaps::bc_bound(), fill = NA, color = "black") +  # BC boundary
#   geom_sf(data = wb_list, color = "blue", alpha = 0.5) +  # Waterbodies
#   scale_fill_manual(
#     values = c("0" = "lightgreen", "1" = "purple"),
#     na.value = "transparent"  # Handle NA values
#   ) +
#   labs(fill = 'Suitable\nHabitat') +
#   ggthemes::theme_map()+
#   theme(legend.position = "right",
#         plot.background = element_rect(fill = 'lightblue'))
}

# For the wbs_list, find the overlap with the raster abd add a column for tubifex habitat suitability.
bc_crs <- "EPSG:3005"
tubifex_maxent <- project(tubifex_maxent, bc_crs, method = "near")
wb_vect <- vect(wb_list)
factor_levels <- levels(tubifex_maxent)[[1]]  # Only one layer
extracted <- extract(tubifex_maxent, wb_vect)
extracted <- dplyr::left_join(extracted, factor_levels, by = "fc.LQ_rm.3")

suitability_summary <- extracted |>
  group_by(ID.x) |>
  summarize(
    max_val = if (all(is.na(fc.LQ_rm.3))) NA_real_ else max(as.numeric(fc.LQ_rm.3), na.rm = TRUE)
  ) |>
  mutate(
    tubifex_habitat_suitability = case_when(
      is.na(max_val) ~ NA_character_,
      max_val >= 1 ~ "suitable",
      TRUE ~ "unsuitable"
    )
  )

wb_list$tubifex_habitat_suitability <- suitability_summary$tubifex_habitat_suitability

```

### Mining Sites 

Current method: count number of mining sites within 5km of each waterbody.
```{r mines_across_BC, fig.width = 9, fig.height = 6}
if(!file.exists("data/mining_bcdata_layer.rds")){
  mining = bcl[str_detect(bcl,"mine-")]
  
  mines = bcdc_query_geodata(mining[1]) |>
    collect()
  
  saveRDS(mines, file = "data/mining_bcdata_layer.rds")
} else {
  mines = readRDS("data/mining_bcdata_layer.rds")
}

ggplot() +
  geom_sf(data = bcmaps::bc_bound()) + 
  geom_sf(data = mines)

DT::datatable(mines |> sf::st_drop_geometry() |> 
                dplyr::slice(1:10) |> dplyr::select(-TENURE_NUMBER)
                )

mines_nearby = mines |> 
  sf::st_buffer(dist = 5000) |> 
  sf::st_join(wb_list |> dplyr::select(GNIS_NA, WATERSH)) |> 
  sf::st_drop_geometry() |> 
  dplyr::count(GNIS_NA, WATERSH, name = "mines_nearby")

wb_list = wb_list |> 
  dplyr::left_join(mines_nearby)
```

### Recreation Sites

Current method: count number of recreation sites within 500 meters of each waterbody.

```{r rec_sites_across_BC, fig.width = 9, fig.height = 6}
if(!file.exists("data/rec_sites_bcdata_layer.rds")){
  recsites = bcl[str_detect(bcl,'recreation-site')]
  
  reccies = bcdc_query_geodata(recsites[12]) |>
    collect() |>
    dplyr::filter(PROJECT_TYPE == 'SIT - Recreation Site')
  
  saveRDS(reccies, file = "data/rec_sites_bcdata_layer.rds")
} else {
  reccies = readRDS("data/rec_sites_bcdata_layer.rds")
}

ggplot() +
  geom_sf(data = bcmaps::bc_bound()) + 
  geom_sf(data = reccies)

DT::datatable(reccies |> sf::st_drop_geometry() |> 
                dplyr::slice(1:10) |> dplyr::select(-c(DRIVING_DIRECTIONS,
                                                      SITE_DESCRIPTION)))

reccies_nearby = reccies |> 
  sf::st_buffer(dist = 500) |> 
  sf::st_join(wb_list |> dplyr::select(GNIS_NA, WATERSH)) |> 
  sf::st_drop_geometry() |> 
  dplyr::count(GNIS_NA, WATERSH, name = "rec_sites_nearby")

wb_list = wb_list |> 
  dplyr::left_join(reccies_nearby)
```

### Provincial Parks and Protected Areas

Current method: count number of provincial parks and protected areas within 500 meters of each waterbody.

```{r parks_protected_areas_across_BC, fig.width = 9, fig.height = 6}
if(!file.exists("data/parks_prot_areas_bcdata_layer.rds")){
  parks = bcdc_query_geodata('terrestrial-protected-areas-representation-by-ecosection-parc-') |>
    collect()
  # Note: variable PROTECTED_AREA_TYPE has levels PROVINCIAL PARK (1038), NGO CONSERVANCY (603), etc.

  saveRDS(parks, file = "data/parks_prot_areas_bcdata_layer.rds")
} else {
  parks = readRDS("data/parks_prot_areas_bcdata_layer.rds")
}

parks |> 
  sf::st_drop_geometry() |> 
  dplyr::count(PROTECTED_AREA_TYPE, sort = T) |> 
  knitr::kable()

ggplot() +
  geom_sf(data = bcmaps::bc_bound()) + 
  geom_sf(data = parks, aes(col = PROTECTED_AREA_TYPE, fill = PROTECTED_AREA_TYPE))

DT::datatable(parks |> sf::st_drop_geometry() |> dplyr::slice(1:10))

parks_nearby = parks |> 
  sf::st_buffer(dist = 500) |> 
  sf::st_join(wb_list |> dplyr::select(GNIS_NA, WATERSH)) |> 
  sf::st_drop_geometry() |> 
  dplyr::count(GNIS_NA, WATERSH, name = "parks_prot_areas_nearby")

wb_list = wb_list |> 
  dplyr::left_join(parks_nearby)

```

### Overlay Susceptible Species Occurrences

viii. Overlay susceptible species occurrences (present/absent for each waterbody) and facet map by species at this stage; maybe later we'll remove WBs with 0. We could apply this and show the effect of doing this.

The species considered susceptible to whirling disease are:

```{r overlay_susceptible_species, fig.width = 8, fig.height = 6}

# Fish occurrence records queried from typical data sources.
library(bcinvadeR)

bc<-bcmaps::bc_bound() |> 
  sf::st_transform(4326)

# # Quick check - what are all of the different species in the known-bc-fish-occurrences layer that mention 'Whitefish' in the species name?
# my_query = bcdata:::CQL("SPECIES_NAME like '%Whitefish'")
# 
# all_whitefish_recs = bcdc_query_geodata("aca81811-4b08-4382-9af7-204e0b9d2448") |> 
#   filter(my_query) |> 
#   collect()
# 
# all_whitefish_recs |> 
#   sf::st_drop_geometry() |> 
#   dplyr::count(SPECIES_NAME)
# There are Broad, Giant Pygmy, Lake, ountain, Pygmy, and Round Whitefish.

species_names <- c(
  "Bull Trout", "Sockeye Salmon", "Cutthroat Trout", "Coho Salmon",
  "Rainbow Trout", "Chinook Salmon", "Mountain Whitefish", 
  "Atlantic Salmon", "Brown Trout", "Brook Trout", "Westslope Cutthroat Trout",
  "Steelhead","Lake Whitefish","Round Whitefish","Pygmy Whitefish"
)

if(requery_occs){
  species_occs <- lapply(species_names, function(sp) {
    ocs<-try(suppressMessages(suppressWarnings(grab_aq_occ_data(sp, quiet = TRUE, sources = c("FDIS","Old Aquatic","iNaturalist")))))
    if (!is.null(ocs)) {
      outfile <- paste0("data/", gsub(" ", "_", sp), "_occurrences.gpkg")
      sf::write_sf(ocs, outfile)
    }
    return(ocs)
  })
  
}else{
  species_occs <- lapply(species_names, function(sp) {
    sf::read_sf(paste0("data/", gsub(" ", "_", sp), "_occurrences.gpkg"))
  })
}

names(species_occs) <- gsub(" ", "_", species_names)

fish_occs <- bind_rows(species_occs, .id = "species")

# Quick double check of mountain whitefish and rainbow trout.

# ggplot() + geom_sf(data = fish_occs[fish_occs$species == 'Mountain_Whitefish',])
# ggplot() + geom_sf(data = fish_occs[fish_occs$species == 'Rainbow_Trout',])

if(!interactive()){
ggplot() + 
  geom_sf(data = bc, color = "lightgrey") + 
  geom_sf(data = fish_occs, aes(color = as.factor(Species)))+
  facet_wrap( ~ Species)+
  scale_color_viridis_d() +
  labs(color = "Species") +
  ggthemes::theme_map()+
  theme(legend.position = "bottom")
}

# now is there an overlap of susceptible fish with the wb_list, for each species, new column with TRUE/FALSE for the species 

fish_occs<-sf::st_transform(fish_occs, 3005)

# Initialize columns for each species in wb_list
#species_names <-gsub(" ", "_", species_names)  # Ensure species name matches the column name

wb_list$sus_spp <- ""


for (sp in species_names) {
  # Filter points for the species
  spoi<-gsub(" ", "_", sp)
  sp_points <- fish_occs[fish_occs$species == spoi, ]
  
  # Check which waterbodies intersect with any points of this species
  intersects <- st_intersects(wb_list, sp_points, sparse = FALSE)
  
  # Append species name to Fish_present where there's at least one intersecting point
  for (i in seq_len(nrow(wb_list))) {
    if (any(intersects[i, ])) {
      if (wb_list$sus_spp[i] == "") {
        wb_list$sus_spp[i] <- sp
      } else {
        wb_list$sus_spp[i] <- paste(gsub("_", " ",wb_list$sus_spp[i]), sp, sep = ", ")
      }
    }
  }
}

# ggplot() + 
#   geom_sf(data = wb_list[str_detect(wb_list$Fish_present,"Rainbow"),]) +
#   geom_sf(data = fish_occs[fish_occs$species == 'Rainbow_Trout',], col = 'yellow') 

# # An alternative to the above!
# fish_occs_by_wb = fish_occs |> 
#   st_join(wb_list |> dplyr::select(GNIS_NA,WATERSH))
# 
# fish_occs_by_wb = fish_occs_by_wb |> 
#   sf::st_drop_geometry() |> 
#   dplyr::group_by(GNIS_NA, WATERSH) |> 
#   dplyr::reframe(Species = paste0(unique(Species), collapse = ', '))
# 
# wb_list = wb_list |> 
#   dplyr::left_join(fish_occs_by_wb)

# wb_list |> dplyr::filter(str_detect(Fish_present,"[rR]ainbow"))

# The above looks perfect!

# get the sara listed species in each of the listed waterbodies

sara_sp<-sf::read_sf(paste0(onedrive_wd,"CNF/DFO_SARA_occ_data_QGIS_simplified_SouthCoastBullTrout.gpkg"))

sara_sp <- sf::st_transform(sara_sp, st_crs(wb_list))

# Perform spatial join: match SARA species polygons to waterbodies
wb_with_sara <- st_join(wb_list, sara_sp |> select(Common_Name_EN), left = TRUE)

# Create or update a `sara` column: list of overlapping species names
wb_with_sara_grouped <- wb_with_sara |>
  group_by(across(all_of(names(wb_list)))) |>  # Group by original wb_list columns
  summarise(sara = paste(unique(Common_Name_EN[!is.na(Common_Name_EN)]), collapse = "; "),
            .groups = "drop")

# Replace empty strings with NA (no SARA species overlap)
wb_with_sara_grouped <- wb_with_sara_grouped |>
  mutate(sara = na_if(trimws(sara), ""))

wb_list<-wb_with_sara_grouped
rm(wb_with_sara_grouped, sara_sp, wb_with_sara)

```

```{r species_stocked_in_waterbodies}
stonks = read_excel("data/hand-picked stocking locations.xlsx")

stonks_sf = stonks |> 
  dplyr::mutate(across(c(hand_lng,hand_lat), \(x) as.numeric(x))) |> 
  dplyr::filter(!is.na(hand_lng)) |> 
  dplyr::filter(!is.na(hand_lat)) |> 
  dplyr::filter(is.numeric(hand_lng)) |> 
  sf::st_as_sf(coords = c('hand_lng','hand_lat'), crs = 4326)

# grab the species stocked in each.
dat2024<-read.csv(paste0(onedrive_wd,"FFSBC_fish_stocking_2024.csv"))
dat2023<-read.csv(paste0(onedrive_wd,"FFSBC_fish_stocking_2023.csv"))
dat2022<-read.csv(paste0(onedrive_wd,"FFSBC_fish_stocking_2022.csv"))

dat2022 <- dat2022 |>  mutate(Year = 2022)
dat2023 <- dat2023 |>  mutate(Year = 2023)
dat2024 <- dat2024 |>  mutate(Year = 2024)

all_years <- bind_rows(dat2022, dat2023, dat2024)

stonks_sf_w_species = stonks_sf |> 
  inner_join(all_years) |> 
  dplyr::select(-c(lng,lat)) |> 
  dplyr::group_by(Waterbody.Name, Nearest.Town) |> 
  dplyr::summarise(stocked_species = paste0(unique(Species), collapse = ', '),
                 geometry = st_union(geometry)) |> 
  dplyr::ungroup() |> 
  sf::st_transform(crs = st_crs(wb_list))

# Do the little reverse spatial join thingy.
stonks_sf_w_species_w_wblist = stonks_sf_w_species |> 
  st_join(
    wb_list |> dplyr::select(GNIS_NA,WATERSH)
  )

stocking_summarised_by_wb_list = stonks_sf_w_species_w_wblist |> 
  sf::st_drop_geometry() |> 
  dplyr::group_by(GNIS_NA, WATERSH) |> 
  dplyr::reframe(stocked_species = paste0(unique(stocked_species), collapse = ', '))

wb_list = wb_list |> 
  dplyr::left_join(
    stocking_summarised_by_wb_list
  )

DT::datatable(wb_list |> sf::st_drop_geometry())
```

```{r add_if_wb_was_sampled_in_2024}
wb_sampled_2024 = wb_list |> 
  sf::st_filter(
    sf::st_as_sf(
      wbs_sampled_2024,
      coords = c("long","lat"),
      crs = 4326
    ) |> sf::st_transform(3005)
  ) |> 
  dplyr::select(GNIS_NA, WATERSH) |> 
  sf::st_drop_geometry() |> 
  dplyr::mutate(sampled_2024 = TRUE)

wb_list = wb_list |> 
  dplyr::left_join(wb_sampled_2024) |> 
  dplyr::mutate(sampled_2024 = tidyr::replace_na(sampled_2024, FALSE))
```

ix. Add in expert opinion from regions, First Nations, etc., as available
x.  In future, we'll bring in SARA-listed species / COSEWIC

```{r add_together_variables}
wb_list = wb_list |> 
  dplyr::mutate(tib = as.numeric(TotalInspections_kmeans_bin),
                iwbc = as.numeric(insp_from_wd_bc_wb_kmeans_bin),
                dfb = as.numeric(days_fished_kmeans_bin),
                wab = as.numeric(active_water_authorizations_kmeans_bin)) |> 
  dplyr::mutate(priority = ifelse(is.na(tib),0,tib) + ifelse(is.na(iwbc),0,iwbc) + ifelse(is.na(dfb),0,dfb) + ifelse(is.na(wab),0,tib)) |> 
  dplyr::select(-c(tib,iwbc,dfb,wab))
```

### Table of All Waterbodies with Data

```{r reorder_final_columns}
wb_list_og = wb_list 

wb_list = wb_list |> 
  dplyr::rename(boats_entering_BC = TotalInspections,
                boats_entering_BC_bin = TotalInspections_kmeans_bin,
                boats_inside_BC = insp_from_wd_bc_wb,
                boats_inside_BC_bin = insp_from_wd_bc_wb_kmeans_bin,
                days_fished_bin = days_fished_kmeans_bin,
                active_water_auths = active_water_authorizations,
                active_water_auths_bin = active_water_authorizations_kmeans_bin,
                susceptible_spp = sus_spp,
                SARA = sara,
                known_fish_occs = known_fish
                ) |> 
  dplyr::select(GNIS_NA:days_fished_bin,
                active_water_auths,active_water_auths_bin,
                priority,
                fish_edna_positive_in_watershed:infectable,tubifex_edna_positive_in_watershed:SARA,stocked_species,known_fish_occs)
```

```{r show_results_data_table}
wb_list |> 
  sf::st_drop_geometry() |> 
  DT::datatable(filter = 'top', options = list(
  pageLength = 10, autoWidth = TRUE))
```

```{r make_list_filtered_for_SARA_overlaps}

wb_list<-st_transform(wb_list, 4326)

wb_list_SARA = wb_list |> 
  dplyr::filter(!is.na(SARA))
```


```{r write_out_results_to_excel_file}
my_wb = openxlsx::createWorkbook()
openxlsx::addWorksheet(my_wb, "All Waterbodies")
openxlsx::addWorksheet(my_wb, "SARA Overlaps")
openxlsx::writeData(my_wb, "All Waterbodies", wb_list |> 
  sf::st_drop_geometry())
openxlsx::writeData(my_wb, "SARA Overlaps", wb_list_SARA |>
  sf::st_drop_geometry())
openxlsx::setColWidths(my_wb, "All Waterbodies", cols = c(1:(ncol(wb_list)-1)), widths = 'auto')
openxlsx::setColWidths(my_wb, "SARA Overlaps", cols = c(1:(ncol(wb_list_SARA)-1)), widths = 'auto')
openxlsx::saveWorkbook(my_wb, paste0("output/Whirling_Disease_priorities_for_waterbody_sampling_",Sys.Date(),".xlsx"), overwrite = T)
```

### Leaflet Map - Provincial Risk

```{r fig.width = 9, fig.height = 6}
library(leaflet)

priority_pal = colorNumeric("viridis", domain = wb_list$priority)
wb_list$priority = as.numeric(wb_list$priority) 


wb_list_over_3 <- wb_list |> filter(priority > 3)

priority_vals <- sort(unique(wb_list_over_3$priority))

m <- leaflet() |>
  addTiles(group = 'openStreetMap') |>
  addProviderTiles(provider = providers$CartoDB, group = 'cartoDB')

# Add a polygon layer for each priority value
for (p in priority_vals) {
  wb_subset <- wb_list_over_3 |> filter(priority == p)

  m <- m |> addPolygons(
    data = wb_subset,
    label = ~paste0(GNIS_NA, " (priority ", priority, ")"),
    fillColor = ~priority_pal(priority),
    fillOpacity = 0.8,
    color = "#333333",
    weight = 1,
    group = paste0("Priority ", p),
    popup = leafpop::popupTable(
      wb_subset |> st_drop_geometry() |> 
        select(GNIS_NA, susceptible_spp, SARA, stocked_species, known_fish_occs, boats_inside_BC_bin, boats_entering_BC_bin, days_fished_bin, priority)
    )
  )
}


# Add layer controls to toggle each priority level
m <- m |> addLayersControl(
  position = 'bottomleft',
  overlayGroups = paste0("Priority ", priority_vals),
  options = layersControlOptions(collapsed = FALSE)
)

# Optionally add legend
m <- m |> addLegend(
  pal = priority_pal,
  values = wb_list$priority,
  title = "Priority",
  position = "topright"
)

# Add reset map button
m = m |> 
  leaflet.extras::addResetMapButton() |> 
  leaflet.extras::addSearchFeatures(
    targetGroups = c(paste0("Priority ",priority_vals)),
    options = leaflet.extras::searchFeaturesOptions(
      zoom=8, openPopup = TRUE, firstTipSubmit = TRUE,
      autoCollapse = F, hideMarkerOnCollapse = TRUE,
    ))

m

```

### Priority Waterbodies with SARA Overlaps
```{r}

priority_pal = colorNumeric("viridis", domain = wb_list_SARA$priority)

priority_vals <- sort(unique(wb_list_SARA$priority))

priority_vals = priority_vals[priority_vals > 3]

m <- leaflet() |>
  addTiles(group = 'openStreetMap') |>
  addProviderTiles(provider = providers$CartoDB, group = 'cartoDB')

# Add a polygon layer for each priority value
for (p in priority_vals) {
  if(p < 4) next
  wb_subset <- wb_list_SARA |> filter(priority == p)

  m <- m |> addPolygons(
    data = wb_subset,
    label = ~paste0(GNIS_NA, " (priority ", priority, ")"),
    fillColor = ~priority_pal(priority),
    fillOpacity = 0.8,
    color = "#333333",
    weight = 1,
    group = paste0("Priority ", p),
    popup = leafpop::popupTable(
      wb_subset |> st_drop_geometry() |> 
        select(GNIS_NA, susceptible_spp, SARA, stocked_species, known_fish_occs, boats_inside_BC_bin, boats_entering_BC_bin, days_fished_bin, priority)
    )
  )
}


# Add layer controls to toggle each priority level
m <- m |> addLayersControl(
  position = 'bottomleft',
  overlayGroups = paste0("Priority ", priority_vals),
  options = layersControlOptions(collapsed = FALSE)
)

# Optionally add legend
m <- m |> addLegend(
  pal = priority_pal,
  values = wb_list_SARA$priority,
  title = "Priority",
  position = "topright"
)

# Add reset map button
m = m |> 
  leaflet.extras::addResetMapButton() |> 
  leaflet.extras::addSearchFeatures(
    targetGroups = c(paste0("Priority ",priority_vals)),
    options = leaflet.extras::searchFeaturesOptions(
      zoom=8, openPopup = TRUE, firstTipSubmit = TRUE,
      autoCollapse = F, hideMarkerOnCollapse = TRUE,
    ))

m
```

