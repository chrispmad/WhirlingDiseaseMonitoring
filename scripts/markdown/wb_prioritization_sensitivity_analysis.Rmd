---
title: "Prioritization of Water Bodies for Whirling Disease Sampling"
author: "Chris Madsen & John Phelan"
date: "`r Sys.Date()`"
output: 
  html_document:
    css: my_style.css
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
library(tidyverse)
library(readxl)
library(BAMMtools)
library(terra)
#devtools::install_github("yutannihilation/ggsflabel")
library(ggsflabel)
library(tidyterra)
library(sf)
library(bcdata)

requery_occs = F
k_breaks = 5 # number of breaks for k-means clustering

base_dir = stringr::str_extract(getwd(),"C:\\/Users\\/[a-zA-Z]+")
onedrive_wd = paste0(str_extract(getwd(),"C:/Users/[A-Z]+/"),"OneDrive - Government of BC/data/")
lan_root = "//SFP.IDIR.BCGOV/S140/S40203/WFC AEB/General/"

#k-means clustering functions
source("utils/bin_to_kmeans_func.R")
source("utils/getKMeansBreaks_func.R")

## GGplot label convenience function
source("utils/bin_info_labs_ggplot_preset.R")
```

```{r load_data}
if(!file.exists('data/anger_survey.rds')){
  insp_from_wd_inf_to_wb = sf::read_sf("W:/CMadsen/Projects/ZQMussels/data/Waterbodies_with_Inspection_Data_Summaries_all_years_WD_Infected_Areas.gpkg")
  saveRDS(insp_from_wd_inf_to_wb, file = 'data/inspections_WD_outside_BC.rds')
} else {
  if(!exists("insp_from_wd_inf_to_wb")){
  insp_from_wd_inf_to_wb = readRDS('data/inspections_WD_outside_BC.rds')
  }
}

if(!exists("insp_from_wd_bc_wb")){
insp_from_wd_bc_wb = sf::read_sf("W:/CMadsen/Projects/ZQMussels/data/Waterbodies_with_Inspection_Data_Summaries_all_years_BC_WD_Infected_Waterbodies.gpkg")
}

if(!file.exists('data/anger_survey.rds')){
  ang = sf::read_sf("W:/CMadsen/shared_data_sets/freshwater_fisheries_society_angler_survey_2022_2023.gpkg")
  saveRDS(ang, file = 'data/anger_survey.rds')
} else {
  ang = readRDS('data/anger_survey.rds')
}

# Which waterbodies were sampled last year?
wbs_sampled_2024 = readxl::read_excel(paste0(lan_root,"2 SCIENCE - Invasives/SPECIES/Whirling Disease/Monitoring/WD_sampling_results_fish_eDNA_used_for_making_maps_CMADSEN.xlsx")) |> 
  purrr::set_names(snakecase::to_snake_case) |> 
  dplyr::filter(sampled_in_2024_y_n == 'Y')
```

## Prioritization Equation {.tabset}

Priority Equation:

$$
P_w = EnteringBC_w + InsideBC_w + FishingDays_w + WaterAuths_w
$$

Where *P~w~* is the priority ranking of a given waterbody, EnteringBC~w~ is the binned number of watercraft destined for a given waterbody from a Whirling Disease-infected state/province/territory that is not BC, InsideBC~w~ is the binned number of watercraft destined for a given waterbody coming from a Whirling Disease-infected waterbody in BC, Fishingdays~w~ is the binned fishing days reported for a given waterbody, and WaterAuths~w~ is the binned number of current water authorization points within a given waterbody.

### Watercraft Inspections Coming from Infected States/Provinces

These are binned watercraft inspections originating from infected states or provinces, as well as from waterbodies in British Columbia (BC) that are infected with whirling disease. The bins represent the number of watercraft headed to BC waterbodies from infected states, provinces, or infected BC waterbodies.

```{r watercraft_insp_from_inf_areas}

# Note: the above file can kind of only be modified / updated on Chris' computer, as it depends on the ZQMussels R project (specifically, it's Options.csv file) and the {imdp} R package... but the output gets saved to Chris' W drive, so that should be accessible for everyone!

insp_from_wd_inf_to_wb_b = bin_to_kmeans(insp_from_wd_inf_to_wb, 'TotalInspections', k_breaks)

# Strip out pacific ocean and 'dry storage' destinations for watercraft.
insp_from_wd_inf_to_wb_b = insp_from_wd_inf_to_wb_b |> 
  dplyr::filter(!GNIS_NA %in% c("Pacific Ocean","Dry Storage"))

bins_title = getKMeansBreaks(insp_from_wd_inf_to_wb_b$TotalInspections, k = k_breaks)

# Plot showing binned numbers of watercraft headed to waterbodies in BC from infected states / provinces as well as infected waterbodies in BC.
if(!interactive()){
ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = insp_from_wd_inf_to_wb_b, aes(
    fill = TotalInspections_kmeans_bin,
    col = TotalInspections_kmeans_bin)) + 
  ggthemes::theme_map() + 
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) + 
  bin_info_labs(bins_title)
}
wb_list = insp_from_wd_inf_to_wb_b |> 
  dplyr::select(GNIS_NA, WATERSH, TotalInspections, TotalInspections_kmeans_bin )
```

Currently, the number of distinct waterbodies with information is `r nrow(wb_list)`.

### Watercraft Inspections Coming from Infected Waterbodies in BC

These are where boats are going when coming from infected BC waterbodies.

```{r watercraft_insp_from_inf_wbs_in_bc}
insp_from_wd_bc_wb_b = bin_to_kmeans(insp_from_wd_bc_wb, 'TotalInspections', k_breaks)

# Strip out pacific ocean and 'dry storage' destinations for watercraft.
insp_from_wd_bc_wb_b = insp_from_wd_bc_wb_b |> 
  dplyr::filter(!GNIS_NA %in% c("Pacific Ocean","Dry Storage"))

bins_title_bc = getKMeansBreaks(insp_from_wd_bc_wb_b$TotalInspections, k = k_breaks)

# Plot showing binned numbers of watercraft headed to waterbodies in BC from infected states / provinces as well as infected waterbodies in BC.
if(!interactive()){
ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = insp_from_wd_bc_wb_b, aes(fill = TotalInspections_kmeans_bin ,
                                             col = TotalInspections_kmeans_bin )) + 
  ggthemes::theme_map() + 
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) + 
  bin_info_labs(bins_title_bc)
}
# Identify any water bodies that aren't already in the list.
new_wb_for_list = insp_from_wd_bc_wb_b |> 
  dplyr::anti_join(
    wb_list |> 
      sf::st_drop_geometry() |> 
      dplyr::select(GNIS_NA, WATERSH)
  ) |> 
  dplyr::select(GNIS_NA, WATERSH,
                insp_from_wd_bc_wb = TotalInspections,
                insp_from_wd_bc_wb_kmeans_bin = TotalInspections_kmeans_bin )

wb_already_in_list = insp_from_wd_bc_wb_b |> 
  dplyr::filter(paste0(WATERSH,GNIS_NA) %in% paste0(wb_list$WATERSH,wb_list$GNIS_NA)) |> 
  dplyr::select(GNIS_NA, WATERSH, insp_from_wd_bc_wb = TotalInspections,
                insp_from_wd_bc_wb_kmeans_bin = TotalInspections_kmeans_bin ) |> 
  sf::st_drop_geometry()

# Not new waterbodies per list, per se, but new columns.
wb_list = wb_list |> 
  dplyr::left_join(
    wb_already_in_list
  )

# Are there any new waterbodies to be added to the wb_list?
if(nrow(new_wb_for_list) > 0){
  wb_list = wb_list |> 
    dplyr::bind_rows(
      new_wb_for_list
    )
}
```

Currently, the number of distinct waterbodies with information is `r nrow(wb_list)`.


### 2023-2024 iSEA Fishing Days

```{r}
dfo_ang = readRDS(paste0(onedrive_wd,"fishing_days_by_waterbody_and_watershed.rds"))
# 
# # wbs present in both
# nrow(ang_s |> dplyr::filter(GNIS_NA %in% dfo_ang$waterbody))
# # wbs only in the 'old' angler survey data.
# nrow(ang_s |> dplyr::filter(!GNIS_NA %in% dfo_ang$waterbody))

# If > 95% of the lakes in the old dataset are present in the new, no question to just move to the new dataset. Numbers are wildly different in scale, though the ordering might be kind of similar.

binned_ang<-bin_to_kmeans(dfo_ang, "fishing_days" , k_breaks)
bin_vals<-getKMeansBreaks(binned_ang$fishing_days, k = k_breaks)                          
if(!interactive()){
 ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = binned_ang, aes(col = fishing_days_kmeans_bin, fill = fishing_days_kmeans_bin)) +
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) +
  ggthemes::theme_map() +
  bin_info_labs(bin_vals,'Fishing Days')
}

 binned_ang<-st_transform(binned_ang, st_crs(wb_list))
binned_ang<- binned_ang |> 
  dplyr::rename( GNIS_NA = waterbody,
                WATERSH = watershed,
                days_fished = fishing_days,
                days_fished_kmeans_bin = fishing_days_kmeans_bin)
# Identify any water bodies that aren't already in the list.
new_wb_for_list = binned_ang |>
  dplyr::anti_join(
    wb_list |>
      sf::st_drop_geometry() |>
      dplyr::select(GNIS_NA, WATERSH)
  ) |>
  dplyr::select(WATERSH, GNIS_NA, days_fished, days_fished_kmeans_bin)

wb_already_in_list = binned_ang |>
  dplyr::filter(paste0(WATERSH,GNIS_NA) %in% paste0(wb_list$WATERSH,wb_list$GNIS_NA)) |>
  dplyr::select(GNIS_NA, WATERSH, days_fished, days_fished_kmeans_bin) |>
  sf::st_drop_geometry()

# Not new waterbodies per list, per se, but new columns.
wb_list = wb_list |>
  dplyr::left_join(
    wb_already_in_list
  )

# Are there any new waterbodies to be added to the wb_list?
if(nrow(new_wb_for_list) > 0){
  wb_list = wb_list |>
    dplyr::bind_rows(
      new_wb_for_list
    )
}


```

Currently, the number of distinct waterbodies with information is `r nrow(wb_list)`.

```{r kfo_filter}


# save it to onedrive
if(!file.exists(paste0(onedrive_wd,"kfo.rds"))){
  kfo <- bcdc_query_geodata("known-bc-fish-observations-and-bc-fish-distributions") |>
  collect() |> 
  st_as_sf()
  saveRDS(kfo, paste0(onedrive_wd,"kfo.rds"))
} else {
  kfo = readRDS(paste0(onedrive_wd,"kfo.rds"))
}

# kfo_spp<- kfo |> 
#   dplyr::select(SPECIES_NAME, geometry)
# 
# joined <- st_join(kfo_spp, wb_list, join = st_intersects, left = FALSE)
# 
# fish_summary <- joined |>
#   group_by(GNIS_NA, WATERSH) |> 
#   summarize(
#     known_fish = paste(sort(unique(SPECIES_NAME)), collapse = ", "),
#     .groups = "drop"
#   )
# 
# wb_list <- wb_list |>
#   left_join(fish_summary, by = c("GNIS_NA", "WATERSH"))

# Filter KFO to fish within waterbody bounds (fast!)
kfo_spp <- kfo |> 
  st_filter(wb_list, .predicate = st_intersects) |> 
  select(SPECIES_NAME, geometry)

# Join from fish to waterbodies (faster)
joined <- st_join(kfo_spp, wb_list, join = st_intersects, left = FALSE)

# Summarize known fish by waterbody
fish_summary <- joined |>
  group_by(GNIS_NA, WATERSH) |> 
  summarize(
    known_fish = paste(sort(unique(SPECIES_NAME)), collapse = ", "),
    .groups = "drop"
  )


new_wb_fish <- fish_summary |>
  anti_join(
    wb_list |> st_drop_geometry() |> select(GNIS_NA, WATERSH),
    by = c("GNIS_NA", "WATERSH")
  )

wb_fish_existing <- fish_summary |>
  filter(paste0(WATERSH, GNIS_NA) %in% paste0(wb_list$WATERSH, wb_list$GNIS_NA))

wb_list<- wb_list |>
  left_join(wb_fish_existing |> st_drop_geometry(), by = c("GNIS_NA", "WATERSH"))
```


### Watershed Groups with Fish Samples with WD

```{r}
ws = sf::read_sf("W:/CMadsen/shared_data_sets/subwatersheds_BC.shp")

edna_results = readxl::read_excel(paste0(lan_root,"2 SCIENCE - Invasives/SPECIES/Whirling Disease/Monitoring/WD_sampling_results_fish_eDNA_used_for_making_maps_CMADSEN.xlsx")) |> 
  purrr::set_names(snakecase::to_snake_case)

pos_fish_plus_parasite_edna = edna_results |> 
  dplyr::filter(stringr::str_detect(fish_sampling_results_q_pcr_mc_detected, 'Positive') | e_dna_results_mc == 'Weak Detection')

pos_fish_edna_sf = sf::st_as_sf(pos_fish_plus_parasite_edna,coords = c('long','lat'), crs = 4326)

# Also pull in emerald lake, find its centroid.
emerald_lake = bcdata::bcdc_query_geodata('freshwater-atlas-lakes') |> 
  bcdata::filter(GNIS_NAME_1 == 'Emerald Lake', WATERBODY_POLY_ID == 705013945) |> 
  collect()

emerald_lake_centroid = emerald_lake |> 
  sf::st_centroid()

ws_w_edna_fish = ws |> 
  sf::st_filter(
    pos_fish_edna_sf |> 
      sf::st_transform(3005) |> 
      dplyr::bind_rows(emerald_lake_centroid)
  )

ws_bbox = sf::st_bbox(ws_w_edna_fish |> sf::st_buffer(dist = 50000))

if(!interactive()){
ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) + 
  geom_sf(data = ws_w_edna_fish, aes(fill = "Positive Fish \neDNA Results")) +
  geom_sf(data = pos_fish_edna_sf, col = 'lightgreen') + 
  geom_sf(data = emerald_lake, fill = 'lightgreen', col = 'lightgreen') + 
  geom_sf_label(data = emerald_lake, aes(label = 'Emerald Lake'), nudge_x = 80000) +
  # geom_sf_label(data = pos_fish_edna_sf, aes(label = sample_site_name), nudge_x = 80000, nudge_y = -100000) +
  ggsflabel::geom_sf_label_repel(data = pos_fish_edna_sf,
                                 aes(label = sample_site_name),
                        force = 10, seed = 10) +
  labs(fill = 'eDNA') + 
  coord_sf(xlim = ws_bbox[c(1,3)],
           ylim = ws_bbox[c(2,4)]) + 
  ggthemes::theme_map() + 
  ggspatial::annotation_scale()
}

wb_list = wb_list |> 
  dplyr::mutate(fish_edna_positive_in_watershed = WATERSH %in% ws_w_edna_fish$WATERSHED_)
```

### Water Authorizations

```{r snag_water_auths}
if(!file.exists('data/water_authorization_points.rds')){
  water_apps = bcdc_query_geodata('water-approval-points') |> 
    # filter(INTERSECTS(wsg)) |> 
    collect()
  water_apps = sf::st_filter(water_apps, bcmaps::bc_bound())
  saveRDS(water_apps,'data/water_authorization_points.rds')
} else {
  water_apps = readRDS('data/water_authorization_points.rds')
}

water_apps = water_apps |> 
  dplyr::mutate(approval_status = dplyr::case_when(
    APPROVAL_STATUS %in% c("Abandoned","Aborted","Cancelled") ~ "Abandoned/Cancelled",
    T ~ APPROVAL_STATUS
  ))

library(leaflet)
uniq_app_stat = unique(water_apps$approval_status)
uniq_app_stat = na.omit(uniq_app_stat)

app_stat_leg = colorFactor(palette = 'Spectral', domain = uniq_app_stat)

l = leaflet() |> 
    addTiles() |> 
  addLayersControl(position = 'bottomleft',
                   overlayGroups = uniq_app_stat,
                   options = layersControlOptions(collapsed = F))

zIndex_base = 300
for(app_stat in uniq_app_stat){
  zIndex_base = zIndex_base + 100
  l = l |> 
    addMapPane(name = app_stat, zIndex = zIndex_base) |> 
    addCircleMarkers(
      data = sf::st_transform(water_apps[water_apps$approval_status == app_stat,], 4326),
      label = app_stat,
      color = 'black',
      weight = 1,
      # color = ~app_stat_leg(approval_status),
      fillColor = ~app_stat_leg(approval_status),
      fillOpacity = 0.8,
      group = app_stat,
      options = pathOptions(pane = app_stat)
    )
}
    
l = l |> 
  addLegend(pal = app_stat_leg, values = uniq_app_stat)

if(!interactive()){
  # ggplot() + 
  #   geom_sf(data = bcmaps::bc_bound()) + 
  #   geom_sf(data = water_apps, aes(col = approval_status))
  l
}

water_apps_w_wb_info = water_apps |> 
  dplyr::filter(approval_status %in% c('Current')) |>
  sf::st_join(wb_list |> dplyr::select(GNIS_NA,WATERSH))

water_apps_w_wb_cumulative = water_apps |> 
  dplyr::filter(approval_status %in% c("Current","Superseded")) |>
  sf::st_join(wb_list |> dplyr::select(GNIS_NA,WATERSH)) |> 
  sf::st_drop_geometry() |> 
  dplyr::filter(!is.na(GNIS_NA)) |> 
  dplyr::count(GNIS_NA,WATERSH, name = "cumulative_authorizations")
  

number_water_apps_per_wb = water_apps_w_wb_info |> 
  dplyr::filter(!is.na(GNIS_NA)) |> 
  sf::st_drop_geometry() |> 
  dplyr::count(GNIS_NA,WATERSH, name = "active_water_authorizations")


# Bin!
number_water_apps_per_wb = bin_to_kmeans(number_water_apps_per_wb, 'active_water_authorizations', k_breaks)

water_auths_bins = getKMeansBreaks(number_water_apps_per_wb$active_water_authorizations, k = k_breaks)

wbs_with_water_apps = wb_list |> 
  dplyr::inner_join(
    number_water_apps_per_wb
  )

if(!interactive()){
 ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = wbs_with_water_apps, aes(col = active_water_authorizations_kmeans_bin, fill = active_water_authorizations_kmeans_bin)) +
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) +
  ggthemes::theme_map() +
  bin_info_labs(water_auths_bins,"Water Auths")
}


wb_list = wb_list |> 
  dplyr::left_join(number_water_apps_per_wb) |> 
  dplyr::mutate(active_water_authorizations = tidyr::replace_na(active_water_authorizations, 0))
```

If we only take Water Authorization points of status type 'Current' and drop all the rest, there are `r nrow(water_apps |> dplyr::filter(approval_status == 'Current'))` points to consider; `r nrow(water_apps_w_wb_info |> dplyr::filter(!is.na(GNIS_NA)))` of these overlap with one of the waterbodies with at least one watercraft inspection tied to it or at least one mention of it in the angler survey data.


### Recreation Sites

Current method: count number of recreation sites within 500 meters of each waterbody.

```{r rec_sites_across_BC, fig.width = 9, fig.height = 6}
if(!file.exists("data/rec_sites_bcdata_layer.rds")){
  recsites = bcl[str_detect(bcl,'recreation-site')]
  
  reccies = bcdc_query_geodata(recsites[12]) |>
    collect() |>
    dplyr::filter(PROJECT_TYPE == 'SIT - Recreation Site')
  
  saveRDS(reccies, file = "data/rec_sites_bcdata_layer.rds")
} else {
  reccies = readRDS("data/rec_sites_bcdata_layer.rds")
}

ggplot() +
  geom_sf(data = bcmaps::bc_bound()) + 
  geom_sf(data = reccies)

DT::datatable(reccies |> sf::st_drop_geometry() |> 
                dplyr::slice(1:10) |> dplyr::select(-c(DRIVING_DIRECTIONS,
                                                      SITE_DESCRIPTION)))

reccies_nearby = reccies |> 
  sf::st_buffer(dist = 500) |> 
  sf::st_join(wb_list |> dplyr::select(GNIS_NA, WATERSH)) |> 
  sf::st_drop_geometry() |> 
  dplyr::count(GNIS_NA, WATERSH, name = "rec_sites_nearby")

wb_list = wb_list |> 
  dplyr::left_join(reccies_nearby)


binned_rec<-bin_to_kmeans(wb_list, "rec_sites_nearby")
bin_vals<-getKMeansBreaks(binned_rec$rec_sites_nearby, k = k_breaks)    

# before plotting, replace with str detect any NA with 0
binned_rec = binned_rec |>
  dplyr::mutate(rec_sites_nearby_kmeans_bin = ifelse(str_detect(rec_sites_nearby_kmeans_bin, "NA"), NA_character_, rec_sites_nearby_kmeans_bin))

if(!interactive()){
 ggplot() + 
  geom_sf(data = bcmaps::bc_bound()) +
  geom_sf(data = binned_rec, aes(col = rec_sites_nearby_kmeans_bin, fill = rec_sites_nearby_kmeans_bin)) +
  scale_fill_brewer(palette = 'Spectral', direction = -1) +
  scale_color_brewer(palette = 'Spectral', direction = -1) +
  ggthemes::theme_map() +
  bin_info_labs(bin_vals,'Rec sites nearby')
}

# we are going to join the binned_rec back onto wb_list
# Identify any water bodies that aren't already in the list.
new_wb_for_list = binned_rec |>
  dplyr::anti_join(
    wb_list |>
      sf::st_drop_geometry() |>
      dplyr::select(GNIS_NA, WATERSH)
  ) |>
  dplyr::select(WATERSH, GNIS_NA, rec_sites_nearby, rec_sites_nearby_kmeans_bin)

wb_already_in_list = binned_rec |>
  dplyr::filter(paste0(WATERSH,GNIS_NA) %in% paste0(wb_list$WATERSH,wb_list$GNIS_NA)) |>
  dplyr::select(GNIS_NA, WATERSH, rec_sites_nearby, rec_sites_nearby_kmeans_bin) |>
  sf::st_drop_geometry()

# Not new waterbodies per list, per se, but new columns.
wb_list = wb_list |>
  dplyr::left_join(
    wb_already_in_list
  )

# Are there any new waterbodies to be added to the wb_list?
if(nrow(new_wb_for_list) > 0){
  wb_list = wb_list |>
    dplyr::bind_rows(
      new_wb_for_list
    )
}

#Set where the text is NA to be a true NA

wb_list = wb_list |> 
  dplyr::mutate(rec_sites_nearby_kmeans_bin = str_detect(rec_sites_nearby_kmeans_bin, "NA") |>
                  tidyr::replace_na(FALSE) |>
                  dplyr::if_else(NA_character_, rec_sites_nearby_kmeans_bin, rec_sites_nearby_kmeans_bin))

wb_list <- wb_list |> 
  dplyr::rename(rec_sites_binned = rec_sites_nearby_kmeans_bin)

```


### Susceptible Species Occurrences

viii. Overlay susceptible species occurrences (present/absent for each waterbody) and facet map by species at this stage; maybe later we'll remove WBs with 0. We could apply this and show the effect of doing this.

The species considered susceptible to whirling disease are:

```{r overlay_susceptible_species, fig.width = 8, fig.height = 6}

# Fish occurrence records queried from typical data sources.
library(bcinvadeR)

bc<-bcmaps::bc_bound() |> 
  sf::st_transform(4326)

# # Quick check - what are all of the different species in the known-bc-fish-occurrences layer that mention 'Whitefish' in the species name?
# my_query = bcdata:::CQL("SPECIES_NAME like '%Whitefish'")
# 
# all_whitefish_recs = bcdc_query_geodata("aca81811-4b08-4382-9af7-204e0b9d2448") |> 
#   filter(my_query) |> 
#   collect()
# 
# all_whitefish_recs |> 
#   sf::st_drop_geometry() |> 
#   dplyr::count(SPECIES_NAME)
# There are Broad, Giant Pygmy, Lake, ountain, Pygmy, and Round Whitefish.

species_names <- c(
  "Bull Trout", "Sockeye Salmon", "Cutthroat Trout", "Coho Salmon",
  "Rainbow Trout", "Chinook Salmon", "Mountain Whitefish", 
  "Atlantic Salmon", "Brown Trout", "Brook Trout", "Westslope Cutthroat Trout",
  "Steelhead","Lake Whitefish","Round Whitefish","Pygmy Whitefish"
)

if(requery_occs){
  species_occs <- lapply(species_names, function(sp) {
    ocs<-try(suppressMessages(suppressWarnings(grab_aq_occ_data(sp, quiet = TRUE, sources = c("FDIS","Old Aquatic","iNaturalist")))))
    if (!is.null(ocs)) {
      outfile <- paste0("data/", gsub(" ", "_", sp), "_occurrences.gpkg")
      sf::write_sf(ocs, outfile)
    }
    return(ocs)
  })
  
}else{
  species_occs <- lapply(species_names, function(sp) {
    sf::read_sf(paste0("data/", gsub(" ", "_", sp), "_occurrences.gpkg"))
  })
}

names(species_occs) <- gsub(" ", "_", species_names)

fish_occs <- bind_rows(species_occs, .id = "species")

# Quick double check of mountain whitefish and rainbow trout.

# ggplot() + geom_sf(data = fish_occs[fish_occs$species == 'Mountain_Whitefish',])
# ggplot() + geom_sf(data = fish_occs[fish_occs$species == 'Rainbow_Trout',])

if(!interactive()){
ggplot() + 
  geom_sf(data = bc, color = "lightgrey") + 
  geom_sf(data = fish_occs, aes(color = as.factor(Species)))+
  facet_wrap( ~ Species)+
  scale_color_viridis_d() +
  labs(color = "Species") +
  ggthemes::theme_map()+
  theme(legend.position = "bottom")
}

# now is there an overlap of susceptible fish with the wb_list, for each species, new column with TRUE/FALSE for the species 

fish_occs<-sf::st_transform(fish_occs, 3005)

# Initialize columns for each species in wb_list
#species_names <-gsub(" ", "_", species_names)  # Ensure species name matches the column name

wb_list$sus_spp <- ""


for (sp in species_names) {
  # Filter points for the species
  spoi<-gsub(" ", "_", sp)
  sp_points <- fish_occs[fish_occs$species == spoi, ]
  
  # Check which waterbodies intersect with any points of this species
  intersects <- st_intersects(wb_list, sp_points, sparse = FALSE)
  
  # Append species name to Fish_present where there's at least one intersecting point
  for (i in seq_len(nrow(wb_list))) {
    if (any(intersects[i, ])) {
      if (wb_list$sus_spp[i] == "") {
        wb_list$sus_spp[i] <- sp
      } else {
        wb_list$sus_spp[i] <- paste(gsub("_", " ",wb_list$sus_spp[i]), sp, sep = ", ")
      }
    }
  }
}

# ggplot() + 
#   geom_sf(data = wb_list[str_detect(wb_list$Fish_present,"Rainbow"),]) +
#   geom_sf(data = fish_occs[fish_occs$species == 'Rainbow_Trout',], col = 'yellow') 

# # An alternative to the above!
# fish_occs_by_wb = fish_occs |> 
#   st_join(wb_list |> dplyr::select(GNIS_NA,WATERSH))
# 
# fish_occs_by_wb = fish_occs_by_wb |> 
#   sf::st_drop_geometry() |> 
#   dplyr::group_by(GNIS_NA, WATERSH) |> 
#   dplyr::reframe(Species = paste0(unique(Species), collapse = ', '))
# 
# wb_list = wb_list |> 
#   dplyr::left_join(fish_occs_by_wb)

# wb_list |> dplyr::filter(str_detect(Fish_present,"[rR]ainbow"))

# The above looks perfect!

# get the sara listed species in each of the listed waterbodies

sara_sp<-sf::read_sf(paste0(onedrive_wd,"CNF/DFO_SARA_occ_data_QGIS_simplified_SouthCoastBullTrout.gpkg"))

sara_sp <- sf::st_transform(sara_sp, st_crs(wb_list))

# Perform spatial join: match SARA species polygons to waterbodies
wb_with_sara <- st_join(wb_list, sara_sp |> select(Common_Name_EN), left = TRUE)

# Create or update a `sara` column: list of overlapping species names
wb_with_sara_grouped <- wb_with_sara |>
  group_by(across(all_of(names(wb_list)))) |>  # Group by original wb_list columns
  summarise(sara = paste(unique(Common_Name_EN[!is.na(Common_Name_EN)]), collapse = "; "),
            .groups = "drop")

# Replace empty strings with NA (no SARA species overlap)
wb_with_sara_grouped <- wb_with_sara_grouped |>
  mutate(sara = na_if(trimws(sara), ""))

wb_list<-wb_with_sara_grouped
rm(wb_with_sara_grouped, sara_sp, wb_with_sara)

```

```{r species_stocked_in_waterbodies}
stonks = read_excel("data/hand-picked stocking locations.xlsx")

stonks_sf = stonks |> 
  dplyr::mutate(across(c(hand_lng,hand_lat), \(x) as.numeric(x))) |> 
  dplyr::filter(!is.na(hand_lng)) |> 
  dplyr::filter(!is.na(hand_lat)) |> 
  dplyr::filter(is.numeric(hand_lng)) |> 
  sf::st_as_sf(coords = c('hand_lng','hand_lat'), crs = 4326)

# grab the species stocked in each.
dat2024<-read.csv(paste0(onedrive_wd,"FFSBC_fish_stocking_2024.csv"))
dat2023<-read.csv(paste0(onedrive_wd,"FFSBC_fish_stocking_2023.csv"))
dat2022<-read.csv(paste0(onedrive_wd,"FFSBC_fish_stocking_2022.csv"))

dat2022 <- dat2022 |>  mutate(Year = 2022)
dat2023 <- dat2023 |>  mutate(Year = 2023)
dat2024 <- dat2024 |>  mutate(Year = 2024)

all_years <- bind_rows(dat2022, dat2023, dat2024)

stonks_sf_w_species = stonks_sf |> 
  inner_join(all_years) |> 
  dplyr::select(-c(lng,lat)) |> 
  dplyr::group_by(Waterbody.Name, Nearest.Town) |> 
  dplyr::summarise(stocked_species = paste0(unique(Species), collapse = ', '),
                 geometry = st_union(geometry)) |> 
  dplyr::ungroup() |> 
  sf::st_transform(crs = st_crs(wb_list))

# Do the little reverse spatial join thingy.
stonks_sf_w_species_w_wblist = stonks_sf_w_species |> 
  st_join(
    wb_list |> dplyr::select(GNIS_NA,WATERSH)
  )

stocking_summarised_by_wb_list = stonks_sf_w_species_w_wblist |> 
  sf::st_drop_geometry() |> 
  dplyr::group_by(GNIS_NA, WATERSH) |> 
  dplyr::reframe(stocked_species = paste0(unique(stocked_species), collapse = ', '))

wb_list = wb_list |> 
  dplyr::left_join(
    stocking_summarised_by_wb_list
  )

DT::datatable(wb_list |> sf::st_drop_geometry())
```

```{r add_if_wb_was_sampled_in_2024}
wb_sampled_2024 = wb_list |> 
  sf::st_filter(
    sf::st_as_sf(
      wbs_sampled_2024,
      coords = c("long","lat"),
      crs = 4326
    ) |> sf::st_transform(3005)
  ) |> 
  dplyr::select(GNIS_NA, WATERSH) |> 
  sf::st_drop_geometry() |> 
  dplyr::mutate(sampled_2024 = TRUE)

wb_list = wb_list |> 
  dplyr::left_join(wb_sampled_2024) |> 
  dplyr::mutate(sampled_2024 = tidyr::replace_na(sampled_2024, FALSE))
```

```{r add_together_variables}
wb_list = wb_list |> 
  dplyr::mutate(tib = as.numeric(TotalInspections_kmeans_bin),
                iwbc = as.numeric(insp_from_wd_bc_wb_kmeans_bin),
                dfb = as.numeric(days_fished_kmeans_bin),
                wab = as.numeric(active_water_authorizations_kmeans_bin)) |> 
  dplyr::mutate(priority = ifelse(is.na(tib),0,tib) + ifelse(is.na(iwbc),0,iwbc) + ifelse(is.na(dfb),0,dfb) + ifelse(is.na(wab),0,wab)) |> 
  dplyr::select(-c(tib,iwbc,dfb,wab))
```

### Table of All Waterbodies with Data

```{r reorder_final_columns}
wb_list_og = wb_list 

wb_list = wb_list |> 
  dplyr::rename(boats_entering_BC = TotalInspections,
                boats_entering_BC_bin = TotalInspections_kmeans_bin,
                boats_inside_BC = insp_from_wd_bc_wb,
                boats_inside_BC_bin = insp_from_wd_bc_wb_kmeans_bin,
                days_fished_bin = days_fished_kmeans_bin,
                active_water_auths = active_water_authorizations,
                active_water_auths_bin = active_water_authorizations_kmeans_bin,
                susceptible_spp = sus_spp,
                SARA = sara,
                known_fish_occs = known_fish
                ) #|> 
  # dplyr::select(GNIS_NA:days_fished_bin,
  #               active_water_auths,active_water_auths_bin,
  #               priority,
  #               fish_edna_positive_in_watershed:infectable,tubifex_edna_positive_in_watershed:SARA,stocked_species,known_fish_occs)
```

```{r show_results_data_table}
wb_list |> 
  sf::st_drop_geometry() |> 
  DT::datatable(filter = 'top', options = list(
  pageLength = 10, autoWidth = TRUE))
```

```{r make_list_filtered_for_SARA_overlaps}

wb_list<-st_transform(wb_list, 4326)

wb_list_SARA = wb_list |> 
  dplyr::filter(!is.na(SARA))
```


### Sensitivity Analysis {.tabset}

#### Changes in priority

Dropping variables changes the priority lists of a range of waterbodies.

```{r sens_analysis, fig.width=14, fig.height=8}


wb_list <- wb_list |> 
  mutate(rec_sites_binned = as.numeric(rec_sites_binned)) |> 
  mutate(rec_sites_binned = replace_na(rec_sites_binned, 0)) |>
  mutate(priority_all = rowSums(across(
            c(boats_entering_BC_bin, boats_inside_BC_bin, days_fished_bin, active_water_auths_bin, rec_sites_binned),
            ~ ifelse(is.na(.), 0, .))),
         rank_all = rank(-priority_all, ties.method = "min"))

drop_one_var_effect <- function(df, drop_var) {
  vars <- c("boats_entering_BC_bin", "boats_inside_BC_bin", "days_fished_bin", "active_water_auths_bin",
            "rec_sites_binned")
  keep_vars <- setdiff(vars, drop_var)
  
  df |> 
    mutate(priority_removed = rowSums(across(all_of(keep_vars), ~ ifelse(is.na(.), 0, .))),
           rank_removed = rank(-priority_removed, ties.method = "min"),
           var_dropped = drop_var)
}

results <- bind_rows(
  drop_one_var_effect(wb_list, "boats_entering_BC_bin"),
  drop_one_var_effect(wb_list, "boats_inside_BC_bin"),
  drop_one_var_effect(wb_list, "days_fished_bin"),
  drop_one_var_effect(wb_list, "active_water_auths_bin"),
  drop_one_var_effect(wb_list, "rec_sites_binned")
)

results <- results |> 
  mutate(rank_change = rank_removed - rank_all) |> 
  dplyr::mutate(change_in_priority = (as.numeric(priority_all) - 
                  as.numeric(priority_removed)) -5 )

wb_list <- wb_list |> 
  mutate(wb_id = paste(GNIS_NA, WATERSH, sep = "_"))

results <- results |> 
  mutate(wb_id = paste(GNIS_NA, WATERSH, sep = "_"))

                
library(data.table)
setDT(results)

test<-results[, .N, by = .(var_dropped, change_in_priority)]

results_no_fishing<-results |> 
  dplyr::filter(str_detect(var_dropped, "days_fished_bin")) |> 
  st_drop_geometry()

results_boats_bc<-results |> 
  dplyr::filter(str_detect(var_dropped, "boats_entering_BC_bin")) |> 
  st_drop_geometry()

results_boats_inside_bc<-results |>
  dplyr::filter(str_detect(var_dropped, "boats_inside_BC_bin")) |> 
  st_drop_geometry()

results_active_water_auths<-results |>
  dplyr::filter(str_detect(var_dropped, "active_water_auths_bin")) |> 
  st_drop_geometry()

results_rec_sites<-results |>
  dplyr::filter(str_detect(var_dropped, "rec_sites_binned")) |> 
  st_drop_geometry()

results_summary1 <- results[, .(
  mean_abs_rank_change = mean(abs(rank_change), na.rm = TRUE),
  median_abs_rank_change = median(abs(rank_change), na.rm = TRUE),
  max_rank_change = max(rank_change, na.rm = TRUE),
  min_rank_change = min(rank_change, na.rm = TRUE)
), by = var_dropped][order(-mean_abs_rank_change)]

#print(results_summary1)

results_summary2 <- results[, .(
  num_positive_change = sum(rank_change > 0, na.rm = TRUE),
  num_negative_change = sum(rank_change < 0, na.rm = TRUE),
  num_zero_change = sum(rank_change == 0, na.rm = TRUE)
), by = var_dropped]

#print(results_summary2)

# ggplot(results, aes(x = var_dropped, y = rank_change)) +
#   geom_boxplot() +
#   geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
#   labs(title = "Rank Change Distribution When Dropping Variables",
#        y = "Change in Rank",
#        x = "Variable Dropped") +
#   theme_minimal()

# ggplot(results, aes(x = var_dropped, y = change_in_priority)) +
#   geom_boxplot() +
#   geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
#   labs(title = "Priority Change Distribution When Dropping Variables",
#        y = "Change in Priority",
#        x = "Variable Dropped") +
#   theme_minimal()


top50_ids <- wb_list |> 
  arrange(desc(priority_all)) |>  # assuming higher = higher priority
  slice(1:50) |> 
  pull(wb_id)

top50_results <- results[wb_id %in% top50_ids]

## I want to plot the change in priority, for any waterbody that has a change in priority > 1
top50_results <- top50_results[abs(change_in_priority) > 1]
ggplot()+
  geom_bar(data = top50_results, aes(x = reorder(wb_id, priority), y = change_in_priority, fill = var_dropped), stat = "identity") +
  coord_flip() +
  labs(title = "Change in Priority for Top 50 Waterbodies When Dropping Variables",
       x = "Waterbody ID",
       y = "Change in Priority",
       fill = "Variable Dropped") +
  theme_minimal()+
  facet_wrap(~var_dropped, scales = "free_y")

```

#### Top 50 Waterbodies with Changes in Priority
Now, we look at the top 50 waterbodies with changes in priority :
  
```{r top50_results_table}  
setDT(top50_results)

top50_results |> st_drop_geometry() |> 
  dplyr::select(wb_id, GNIS_NA, WATERSH, var_dropped, rank_change, change_in_priority, priority_all, priority) |>
  DT::datatable(filter = 'top', options = list(
    pageLength = 10, autoWidth = TRUE))




top50_summary <- top50_results[, .(
  mean_abs_rank_change = as.numeric(mean(abs(rank_change), na.rm = TRUE)),
  median_abs_rank_change = as.numeric(median(abs(rank_change), na.rm = TRUE)),
  max_rank_change = as.numeric(ifelse(all(is.na(rank_change)), NA, max(rank_change, na.rm = TRUE))),
  min_rank_change = as.numeric(ifelse(all(is.na(rank_change)), NA, min(rank_change, na.rm = TRUE))),
  num_waterbodies_affected = as.integer(sum(!is.na(rank_change) & rank_change != 0))
), by = var_dropped][order(-mean_abs_rank_change)]

#print(top50_summary)

# ggplot(top50_results, aes(x = var_dropped, y = rank_change)) +
#   geom_boxplot(fill = "skyblue") +
#   geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
#   labs(title = "Rank Change for Top 50 Waterbodies When Dropping Variables",
#        y = "Change in Rank (positive = dropped in priority)",
#        x = "Variable Dropped") +
#   theme_minimal()


#top50_summary



rank_change_summary <- results[, .(
  total_affected = sum(rank_change != 0),
  total_unchanged = sum(rank_change == 0),
  max_change = max(abs(rank_change), na.rm = TRUE),
  mean_change = mean(abs(rank_change), na.rm = TRUE),
  most_changed = wb_id[which.max(abs(rank_change))]
), by = var_dropped]

#++print(rank_change_summary)

top_movers <- results[change_in_priority != 0, 
  .SD[order(-abs(change_in_priority))][1:20], 
  by = var_dropped
]
setDT(top_movers)
setDT(wb_list)
change_rank<-results[rank_change != 0, 
  .SD[order(-abs(change_in_priority))][1:20], 
  by = var_dropped
]

top_movers_named <- merge(top_movers, wb_list[, .(wb_id, GNIS_NA, WATERSH)], by = "wb_id", all.x = TRUE)

top_movers_named <- top_movers_named |>
  mutate(
    GNIS_NA = ifelse(!is.na(GNIS_NA.x), GNIS_NA.x, GNIS_NA.y),
    WATERSH = ifelse(!is.na(WATERSH.x), WATERSH.x, WATERSH.y)
  ) |>
  select(-GNIS_NA.x, -GNIS_NA.y, -WATERSH.x, -WATERSH.y)


top_movers_named |> 
  st_drop_geometry() |>
  dplyr::select(GNIS_NA, WATERSH, var_dropped, change_in_priority, priority_all, priority) |>
  DT::datatable(filter = 'top', options = list(
    pageLength = 10, autoWidth = TRUE))



```

#### Change in rank
Each of the waterbodies have a potential to lose up to 5 points in priority, when dropping one parameter from the equation. This does not correlate to a change in their overall position, as the removal of a parameter could result in a downward shift in all waterbodies, with their relative positions unaffected. So, looking at the rank position gives us an idea of where waterbodies have moved within the list. 


First, boats entering BC has been removed:

```{r rank_entering_bc}

outside_inspections <- results |> 
  dplyr::filter(str_detect(var_dropped, "boats_entering_BC_bin")) |> 
  dplyr::filter(rank_change != 0) |> 
  dplyr::select(wb_id, GNIS_NA, WATERSH, rank_change, change_in_priority, priority_all, priority)

DT::datatable(outside_inspections |> 
  st_drop_geometry() |> 
  dplyr::select(GNIS_NA, WATERSH, rank_change, change_in_priority, priority_all, priority),
  filter = 'top', options = list(
    pageLength = 10, autoWidth = TRUE))
  

```




Then, boats inside BC:

```{r rank_inside_bc}

inside_inspections <- results |> 
  dplyr::filter(str_detect(var_dropped, "boats_inside_BC_bin")) |> 
  dplyr::filter(rank_change != 0) |> 
  dplyr::select(wb_id, GNIS_NA, WATERSH, rank_change, change_in_priority, priority_all, priority)

DT::datatable(inside_inspections |>
  st_drop_geometry() |> 
  dplyr::select(GNIS_NA, WATERSH, rank_change, change_in_priority, priority_all, priority),
  filter = 'top', options = list(
    pageLength = 10, autoWidth = TRUE))
```




Then, days fished:

```{r rank_days_fished}
days_fished <- results |> 
  dplyr::filter(str_detect(var_dropped, "days_fished_bin")) |> 
  dplyr::filter(rank_change != 0) |> 
  dplyr::select(wb_id, GNIS_NA, WATERSH, rank_change, change_in_priority, priority_all, priority)
DT::datatable(days_fished |>
  st_drop_geometry() |> 
  dplyr::select(GNIS_NA, WATERSH, rank_change, change_in_priority, priority_all, priority),
  filter = 'top', options = list(
    pageLength = 10, autoWidth = TRUE))

```




Then, active water authorizations:

```{r rank_water_auths}
active_water_auths <- results |> 
  dplyr::filter(str_detect(var_dropped, "active_water_auths_bin")) |> 
  dplyr::filter(rank_change != 0) |> 
  dplyr::select(wb_id, GNIS_NA, WATERSH, rank_change, change_in_priority, priority_all, priority)

DT::datatable(active_water_auths |>
  st_drop_geometry() |> 
  dplyr::select(GNIS_NA, WATERSH, rank_change, change_in_priority, priority_all, priority),
  filter = 'top', options = list(
    pageLength = 10, autoWidth = TRUE))
```

#### Assessment between the groups

```{r}


rank_change_summary <- results |>
  group_by(wb_id, GNIS_NA, WATERSH) |>
  summarise(
    num_sources_affected = n(),
    mean_abs_rank_change = mean(abs(rank_change), na.rm = TRUE),
    max_abs_rank_change = max(abs(rank_change), na.rm = TRUE),
    total_rank_change = sum(rank_change, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(max_abs_rank_change))

DT::datatable(rank_change_summary, 
              filter = 'top', 
              options = list(pageLength = 10, autoWidth = TRUE))

```





```{r fig.width = 9, fig.height = 6}
### Leaflet Map - Provincial Risk
# library(leaflet)
# 
# priority_pal = colorNumeric("viridis", domain = wb_list$priority)
# wb_list$priority = as.numeric(wb_list$priority) 
# 
# 
# wb_list_over_3 <- wb_list |> filter(priority > 3)
# 
# priority_vals <- sort(unique(wb_list_over_3$priority))
# 
# m <- leaflet() |>
#   addTiles(group = 'openStreetMap') |>
#   addProviderTiles(provider = providers$CartoDB, group = 'cartoDB')
# 
# # Add a polygon layer for each priority value
# for (p in priority_vals) {
#   wb_subset <- wb_list_over_3 |> filter(priority == p)
# 
#   m <- m |> addPolygons(
#     data = wb_subset,
#     label = ~paste0(GNIS_NA, " (priority ", priority, ")"),
#     fillColor = ~priority_pal(priority),
#     fillOpacity = 0.8,
#     color = "#333333",
#     weight = 1,
#     group = paste0("Priority ", p),
#     popup = leafpop::popupTable(
#       wb_subset |> st_drop_geometry() |> 
#         select(GNIS_NA, susceptible_spp, SARA, stocked_species, known_fish_occs, boats_inside_BC_bin, boats_entering_BC_bin, days_fished_bin, priority)
#     )
#   )
# }
# 
# 
# # Add layer controls to toggle each priority level
# m <- m |> addLayersControl(
#   position = 'bottomleft',
#   overlayGroups = paste0("Priority ", priority_vals),
#   options = layersControlOptions(collapsed = FALSE)
# )
# 
# # Optionally add legend
# m <- m |> addLegend(
#   pal = priority_pal,
#   values = wb_list$priority,
#   title = "Priority",
#   position = "topright"
# )
# 
# # Add reset map button
# m = m |> 
#   leaflet.extras::addResetMapButton() |> 
#   leaflet.extras::addSearchFeatures(
#     targetGroups = c(paste0("Priority ",priority_vals)),
#     options = leaflet.extras::searchFeaturesOptions(
#       zoom=8, openPopup = TRUE, firstTipSubmit = TRUE,
#       autoCollapse = F, hideMarkerOnCollapse = TRUE,
#     ))
# 
# # m

```

### Priority Waterbodies with SARA Overlaps

```{r}
# 
# priority_pal = colorNumeric("viridis", domain = wb_list_SARA$priority)
# 
# priority_vals <- sort(unique(wb_list_SARA$priority))
# 
# priority_vals = priority_vals[priority_vals > 3]
# 
# m <- leaflet() |>
#   addTiles(group = 'openStreetMap') |>
#   addProviderTiles(provider = providers$CartoDB, group = 'cartoDB')
# 
# # Add a polygon layer for each priority value
# for (p in priority_vals) {
#   if(p < 4) next
#   wb_subset <- wb_list_SARA |> filter(priority == p)
# 
#   m <- m |> addPolygons(
#     data = wb_subset,
#     label = ~paste0(GNIS_NA, " (priority ", priority, ")"),
#     fillColor = ~priority_pal(priority),
#     fillOpacity = 0.8,
#     color = "#333333",
#     weight = 1,
#     group = paste0("Priority ", p),
#     popup = leafpop::popupTable(
#       wb_subset |> st_drop_geometry() |> 
#         select(GNIS_NA, susceptible_spp, SARA, stocked_species, known_fish_occs, boats_inside_BC_bin, boats_entering_BC_bin, days_fished_bin, priority)
#     )
#   )
# }
# 
# 
# # Add layer controls to toggle each priority level
# m <- m |> addLayersControl(
#   position = 'bottomleft',
#   overlayGroups = paste0("Priority ", priority_vals),
#   options = layersControlOptions(collapsed = FALSE)
# )
# 
# # Optionally add legend
# m <- m |> addLegend(
#   pal = priority_pal,
#   values = wb_list_SARA$priority,
#   title = "Priority",
#   position = "topright"
# )
# 
# # Add reset map button
# m = m |> 
#   leaflet.extras::addResetMapButton() |> 
#   leaflet.extras::addSearchFeatures(
#     targetGroups = c(paste0("Priority ",priority_vals)),
#     options = leaflet.extras::searchFeaturesOptions(
#       zoom=8, openPopup = TRUE, firstTipSubmit = TRUE,
#       autoCollapse = F, hideMarkerOnCollapse = TRUE,
#     ))
# 
# m
```
